<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Jobcenter Letter Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="app">
    <h1 id="title">Проверка письма Jobcenter</h1>
    <p id="subtitle">Помогаем понять, требуется ли действие по письму.</p>

    <div class="card">
      <h3 id="chooseLang">Выберите язык</h3>

      <div class="lang-buttons">
        <button id="btnRu" type="button">RU Русский</button>
        <button id="btnUa" type="button">UA Українська</button>
      </div>

      <p id="disclaimer">
        Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.
      </p>

      <!-- Upload -->
      <button id="uploadBtn" class="btn" type="button">Загрузить письмо</button>
      <input id="fileInput" type="file" accept="application/pdf,image/*" style="display:none" />

      <div id="fileInfo" style="margin-top:10px; opacity:0.95;"></div>

      <!-- Image preview -->
      <img id="imagePreview" alt="" style="display:none; margin-top:10px; width:100%; border-radius:12px;" />

      <!-- Tips -->
      <div id="tipsBox" style="display:none; margin-top:10px; padding:10px 12px; border-radius:12px; background:rgba(0,0,0,0.12);">
        <div id="tipsTitle" style="font-weight:700; margin-bottom:6px;">Советы для хорошего OCR</div>
        <div id="tipsText" style="white-space:pre-wrap; opacity:0.95;"></div>
      </div>

      <!-- Controls -->
      <button id="ocrBtn" class="btn" type="button" style="margin-top:10px; width:100%; display:none;">
        Распознать текст (OCR)
      </button>

      <button id="pdfBtn" class="btn" type="button" style="margin-top:10px; width:100%; display:none;">
        Извлечь текст из PDF
      </button>

      <div id="statusBox" style="margin-top:8px; opacity:0.9; display:none;"></div>

      <!-- Text input -->
      <div style="margin-top:14px;">
        <label id="pasteLabel" for="textInput" style="display:block; margin-bottom:8px; opacity:0.95;">
          Текст письма (можно вставить вручную, если нужно)
        </label>

        <textarea
          id="textInput"
          rows="7"
          placeholder="Вставьте сюда текст письма Jobcenter…"
          style="width:100%; padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.15); background:rgba(0,0,0,0.12); color:inherit; resize:vertical;"
        ></textarea>

        <!-- Оставляем кнопку как запасной вариант -->
        <button id="analyzeBtn" class="btn" type="button" style="margin-top:10px; width:100%;">
          Анализировать
        </button>
      </div>

      <!-- Result -->
      <div id="resultBox" style="display:none; margin-top:12px; padding:12px; border-radius:12px; background:rgba(0,0,0,0.12);">
        <div id="resultTitle" style="font-weight:700; margin-bottom:6px;"></div>
        <div id="resultDetails" style="white-space:pre-wrap; opacity:0.95;"></div>

        <div style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.12);">
          <div id="aboutTitle" style="font-weight:700; margin-bottom:6px;">Кратко о письме</div>
          <div id="aboutText" style="white-space:pre-wrap; opacity:0.95;"></div>
        </div>

        <div style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.12);">
          <div id="trTitle" style="font-weight:700; margin-bottom:6px;">Перевод</div>
          <div id="trText" style="white-space:pre-wrap; opacity:0.95;">
            (Скоро) Подключим AI-перевод: письмо будет переведено понятным языком независимо от результата анализа.
          </div>
          <button class="btn" type="button" style="margin-top:10px; width:100%;" disabled>
            Перевести (скоро)
          </button>
        </div>
      </div>

      <p class="hint" id="hint" style="margin-top:12px;">
        PDF: нажмите “Извлечь текст” → если PDF защищён/особый, включится OCR 1-й страницы автоматически. Анализ запускается сам.
      </p>
    </div>

    <small class="version">v1.0 · PDF parse (no worker) + PDF OCR fallback + auto-analyze</small>
  </div>

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.js"></script>

  <script>
    // Telegram init (safe)
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg) { tg.ready(); tg.expand(); }

    // NOTE: В Telegram WebView worker часто ломается. Мы отключаем worker в getDocument().
    // pdfjsLib.GlobalWorkerOptions.workerSrc оставляем, но основное — disableWorker:true.
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.js";
    }

    const TEXTS = {
      ru: {
        title: "Проверка письма Jobcenter",
        subtitle: "Помогаем понять, требуется ли действие по письму.",
        chooseLang: "Выберите язык",
        disclaimer: "Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.",
        upload: "Загрузить письмо",
        pasteLabel: "Текст письма (можно вставить вручную, если нужно)",
        pastePlaceholder: "Вставьте сюда текст письма Jobcenter…",
        analyze: "Анализировать",
        hint: "PDF: нажмите “Извлечь текст” → если PDF защищён/особый, включится OCR 1-й страницы автоматически. Анализ запускается сам.",

        ocrBtn: "Распознать текст (OCR)",
        pdfBtn: "Извлечь текст из PDF",
        fileInfo: (name, kb, type) => `Файл: ${name} (${kb} KB) · Тип: ${type}`,

        pickedImage: "✅ Изображение выбрано. Можно нажать OCR.",
        pickedPdf: "✅ PDF выбран. Нажмите «Извлечь текст из PDF».",
        unknownType: "⚠️ Неизвестный тип файла. Попробуйте PDF или изображение.",

        tipsTitle: "Советы для хорошего OCR",
        tipsText:
          "• Держите камеру ровно сверху (без наклона)\n" +
          "• Поднесите ближе: текст должен занимать 70–90% кадра\n" +
          "• Уберите блики и тени\n" +
          "• Лучше яркий свет, чем тёмный кадр\n" +
          "• Если размыто — сделайте фото ещё раз",

        status_ocr_working: (p) => `OCR работает… ${p}%`,
        status_ocr_done: "OCR готово. Текст очищен и вставлен в поле ниже. Анализ выполнен автоматически.",
        status_ocr_fail: "OCR не получилось. Попробуйте фото чётче/ближе и без бликов.",

        status_pdf_loading: "Читаю PDF…",
        status_pdf_page: (p, total) => `Извлекаю текст из PDF: страница ${p}/${total}…`,
        status_pdf_done: (chars) => `✅ Текст из PDF извлечён (${chars} символов). Анализ выполнен автоматически.`,
        status_pdf_empty: "⚠️ В PDF почти нет извлекаемого текста. Включаю OCR 1-й страницы…",
        status_pdf_fail_to_open: "Не удалось открыть PDF (особый/защищённый формат). Включаю OCR 1-й страницы…",
        status_pdf_ocr_page: (p) => `PDF → OCR: страница ${p}…`,
        status_pdf_ocr_done: "✅ PDF OCR готов. Текст вставлен. Анализ выполнен автоматически.",
        status_pdf_all_fail: "❌ Не удалось обработать PDF. Попробуйте другой файл или сделайте фото письма.",

        res_needAction: "✅ Требуется действие",
        res_noAction: "❌ Действие не требуется (скорее всего)",
        res_unclear: "⚠️ Неясно — нужна проверка",
        res_empty: "Введите/вставьте текст письма — хотя бы 2–3 строки.",

        details_needAction: (deadline) =>
          `Похоже, Jobcenter ожидает от вас действие.\n` +
          (deadline ? `Обнаружен возможный срок: ${deadline}\n` : "") +
          `Дальше: проверьте, что именно требуют (документы/ответ/явка) и подготовьте действие.`,
        details_noAction:
          `Похоже, это уведомление/информация.\n` +
          `Если в тексте нет просьбы прислать документы, прийти в термин или ответить — часто действие не требуется.\n` +
          `Если сомневаетесь — лучше перепроверить.`,
        details_unclear:
          `Сигналы неочевидны.\n` +
          `Для точности нужны 1–2 абзаца со сроком/термином (Bitte/Frist/Termin).`,

        about_unknown: "Пока не удаётся надёжно определить тип письма. Добавьте 1–2 абзаца с основной частью.",
        about_payment: "Похоже на письмо о выплате/суммах (Bürgergeld, Zahlung, Betrag). Обычно это информирование.",
        about_decision: "Похоже на решение/уведомление (Bescheid/Änderungsbescheid). Часто действие не требуется, но важно проверить: есть ли просьба/срок.",
        about_appointment: "Похоже на приглашение/термин (Termin/Einladung). Обычно требуется действие: прийти/ответить.",
        about_documents: "Похоже на запрос документов/содействие (Unterlagen/Nachweise/Mitwirkung). Обычно требуется действие."
      },

      ua: {
        title: "Перевірка листа Jobcenter",
        subtitle: "Допомагаємо зрозуміти, чи потрібна дія за листом.",
        chooseLang: "Оберіть мову",
        disclaimer: "Це не юридична консультація. Сервіс показує лише: чи потрібна дія за листом.",
        upload: "Завантажити лист",
        pasteLabel: "Текст листа (можна вставити вручну, якщо потрібно)",
        pastePlaceholder: "Вставте сюди текст листа Jobcenter…",
        analyze: "Аналізувати",
        hint: "PDF: натисніть “Витягти текст” → якщо PDF особливий/захищений, увімкнеться OCR 1-ї сторінки. Аналіз запускається сам.",

        ocrBtn: "Розпізнати текст (OCR)",
        pdfBtn: "Витягти текст з PDF",
        fileInfo: (name, kb, type) => `Файл: ${name} (${kb} KB) · Тип: ${type}`,

        pickedImage: "✅ Зображення обрано. Можна натиснути OCR.",
        pickedPdf: "✅ PDF обрано. Натисніть «Витягти текст з PDF».",
        unknownType: "⚠️ Невідомий тип файлу. Спробуйте PDF або зображення.",

        tipsTitle: "Поради для гарного OCR",
        tipsText:
          "• Тримайте камеру рівно зверху (без нахилу)\n" +
          "• Підійдіть ближче: текст має займати 70–90% кадру\n" +
          "• Приберіть відблиски і тіні\n" +
          "• Краще яскраве світло, ніж темний кадр\n" +
          "• Якщо розмито — зробіть фото ще раз",

        status_ocr_working: (p) => `OCR працює… ${p}%`,
        status_ocr_done: "OCR готово. Текст очищено і вставлено нижче. Аналіз виконано автоматично.",
        status_ocr_fail: "OCR не вдалося. Спробуйте чіткіше фото без відблисків.",

        status_pdf_loading: "Читаю PDF…",
        status_pdf_page: (p, total) => `Витяг тексту з PDF: сторінка ${p}/${total}…`,
        status_pdf_done: (chars) => `✅ Текст з PDF витягнуто (${chars} символів). Аналіз виконано автоматично.`,
        status_pdf_empty: "⚠️ У PDF майже немає тексту. Вмикаю OCR 1-ї сторінки…",
        status_pdf_fail_to_open: "Не вдалося відкрити PDF (особливий/захищений формат). Вмикаю OCR 1-ї сторінки…",
        status_pdf_ocr_page: (p) => `PDF → OCR: сторінка ${p}…`,
        status_pdf_ocr_done: "✅ PDF OCR готово. Текст вставлено. Аналіз виконано автоматично.",
        status_pdf_all_fail: "❌ Не вдалося обробити PDF. Спробуйте інший файл або зробіть фото листа.",

        res_needAction: "✅ Потрібна дія",
        res_noAction: "❌ Дія не потрібна (ймовірно)",
        res_unclear: "⚠️ Незрозуміло — потрібна перевірка",
        res_empty: "Вставте текст — хоча б 2–3 рядки.",

        details_needAction: (deadline) =>
          `Схоже, Jobcenter очікує від вас дію.\n` +
          (deadline ? `Можливий строк: ${deadline}\n` : "") +
          `Далі: перевірте, що саме вимагають, і підготуйте дію.`,
        details_noAction:
          `Схоже, це повідомлення/інформація.\n` +
          `Якщо немає прохання надати документи/прийти/відповісти — часто дія не потрібна.\n` +
          `Якщо сумніваєтесь — переперевірте.`,
        details_unclear:
          `Сигнали неочевидні.\n` +
          `Для точності потрібні 1–2 абзаци зі строком/терміном (Bitte/Frist/Termin).`,

        about_unknown: "Поки не вдається надійно визначити тип листа. Додайте 1–2 абзаци з основною частиною.",
        about_payment: "Схоже на лист про виплату/суми (Bürgergeld, Zahlung, Betrag). Зазвичай це інформування.",
        about_decision: "Схоже на рішення/повідомлення (Bescheid/Änderungsbescheid). Часто дія не потрібна, але перевірте: чи є прохання/строк.",
        about_appointment: "Схоже на запрошення/термін (Termin/Einladung). Зазвичай потрібна дія: прийти/відповісти.",
        about_documents: "Схоже на запит документів/співпрацю (Unterlagen/Nachweise/Mitwirkung). Зазвичай потрібна дія."
      }
    };

    let currentLang = "ru";

    // DOM
    const title = document.getElementById("title");
    const subtitle = document.getElementById("subtitle");
    const chooseLang = document.getElementById("chooseLang");
    const disclaimer = document.getElementById("disclaimer");

    const btnRu = document.getElementById("btnRu");
    const btnUa = document.getElementById("btnUa");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");

    const fileInfo = document.getElementById("fileInfo");
    const imagePreview = document.getElementById("imagePreview");

    const tipsBox = document.getElementById("tipsBox");
    const tipsTitle = document.getElementById("tipsTitle");
    const tipsText = document.getElementById("tipsText");

    const ocrBtn = document.getElementById("ocrBtn");
    const pdfBtn = document.getElementById("pdfBtn");
    const statusBox = document.getElementById("statusBox");

    const pasteLabel = document.getElementById("pasteLabel");
    const textInput = document.getElementById("textInput");
    const analyzeBtn = document.getElementById("analyzeBtn");

    const resultBox = document.getElementById("resultBox");
    const resultTitle = document.getElementById("resultTitle");
    const resultDetails = document.getElementById("resultDetails");
    const aboutText = document.getElementById("aboutText");
    const hint = document.getElementById("hint");

    // state
    let currentFile = null;
    let currentKind = null; // 'image' | 'pdf' | null
    let lastDownscaledCanvas = null;
    let autoTimer = null;

    function setLang(lang) {
      currentLang = lang;
      document.documentElement.lang = lang;

      title.textContent = TEXTS[lang].title;
      subtitle.textContent = TEXTS[lang].subtitle;
      chooseLang.textContent = TEXTS[lang].chooseLang;
      disclaimer.textContent = TEXTS[lang].disclaimer;
      uploadBtn.textContent = TEXTS[lang].upload;

      pasteLabel.textContent = TEXTS[lang].pasteLabel;
      textInput.placeholder = TEXTS[lang].pastePlaceholder;

      analyzeBtn.textContent = TEXTS[lang].analyze;
      ocrBtn.textContent = TEXTS[lang].ocrBtn;
      pdfBtn.textContent = TEXTS[lang].pdfBtn;

      tipsTitle.textContent = TEXTS[lang].tipsTitle;
      tipsText.textContent = TEXTS[lang].tipsText;

      hint.textContent = TEXTS[lang].hint;
    }

    // --- Analyzer ---
    function normalize(s) {
      return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
    }

    function findDeadline(text) {
      const m1 = text.match(/\b(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m1) return m1[1];
      const m2 = text.match(/\b(bis zum|spätestens am|frist|fristen|bis spätestens)\s+(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m2) return m2[2];
      return "";
    }

    function analyzeText(raw) {
      const t = normalize(raw);
      if (t.length < 30) return { kind: "empty", deadline: "" };

      const actionSignals = [
        "bitte","wir bitten","sie werden gebeten","sie sind verpflichtet",
        "erforderlich","nachweisen","nachweis","einreichen","vorlegen",
        "termin","einladung","melden sie sich","rückmeldung",
        "frist","bis zum","spätestens","umgehend","sofort",
        "anhörung","mitwirkung","aufforderung","fehlende unterlagen",
        "unterlagen","kontoauszüge","mietvertrag","formular ausfüllen","ausfüllen"
      ];

      const infoSignals = [
        "bewilligung","bescheid","änderungsbescheid","mitteilung","information",
        "zahlung","auszahlung","überweisung","betrag",
        "wir informieren","zur kenntnis","hinweis","bewilligungsbescheid",
        "veränderungsmitteilung"
      ];

      let actionScore = 0, infoScore = 0;
      for (const w of actionSignals) if (t.includes(w)) actionScore++;
      for (const w of infoSignals) if (t.includes(w)) infoScore++;

      const deadline = findDeadline(t);

      if (actionScore >= 2 || (actionScore >= 1 && (t.includes("frist") || t.includes("termin") || deadline))) {
        return { kind: "needAction", deadline };
      }
      if (infoScore >= 2 && actionScore === 0) return { kind: "noAction", deadline: "" };
      return { kind: "unclear", deadline: "" };
    }

    function explainLetter(raw) {
      const t = normalize(raw);
      if (t.length < 30) return TEXTS[currentLang].about_unknown;

      const hasPay = /bürgergeld|zahlung|auszahlung|betrag|überweisung|monatlich/.test(t);
      const hasBescheid = /bescheid|änderungsbescheid|bewilligung|bewilligungsbescheid|mitteilung|veränderungsmitteilung/.test(t);
      const hasTermin = /termin|einladung|melden sie sich|vorsprechen/.test(t);
      const hasDocs = /unterlagen|nachweis|nachweisen|einreichen|vorlegen|mitwirkung|aufforderung|fehlende|ausfüllen|formular/.test(t);

      if (hasTermin) return TEXTS[currentLang].about_appointment;
      if (hasDocs) return TEXTS[currentLang].about_documents;
      if (hasPay) return TEXTS[currentLang].about_payment;
      if (hasBescheid) return TEXTS[currentLang].about_decision;

      return TEXTS[currentLang].about_unknown;
    }

    function showResult(res) {
      resultBox.style.display = "block";

      if (res.kind === "empty") {
        resultTitle.textContent = TEXTS[currentLang].res_unclear;
        resultDetails.textContent = TEXTS[currentLang].res_empty;
        aboutText.textContent = TEXTS[currentLang].about_unknown;
        return;
      }

      if (res.kind === "needAction") {
        resultTitle.textContent = TEXTS[currentLang].res_needAction;
        resultDetails.textContent = TEXTS[currentLang].details_needAction(res.deadline || "");
      } else if (res.kind === "noAction") {
        resultTitle.textContent = TEXTS[currentLang].res_noAction;
        resultDetails.textContent = TEXTS[currentLang].details_noAction;
      } else {
        resultTitle.textContent = TEXTS[currentLang].res_unclear;
        resultDetails.textContent = TEXTS[currentLang].details_unclear;
      }

      aboutText.textContent = explainLetter(textInput.value || "");
    }

    function runAnalyzeNow() {
      const res = analyzeText(textInput.value || "");
      showResult(res);
    }

    function scheduleAutoAnalyze() {
      if (autoTimer) clearTimeout(autoTimer);
      autoTimer = setTimeout(() => runAnalyzeNow(), 800);
    }

    // --- OCR helpers ---
    async function downscaleImageToDataUrl(file, maxSide = 1600) {
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.src = url;
      await new Promise((res, rej) => {
        img.onload = () => res();
        img.onerror = () => rej(new Error("Image load failed"));
      });

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      const scale = Math.min(1, maxSide / Math.max(w, h));
      const nw = Math.round(w * scale);
      const nh = Math.round(h * scale);

      const canvas = document.createElement("canvas");
      canvas.width = nw;
      canvas.height = nh;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, nw, nh);

      URL.revokeObjectURL(url);
      return { dataUrl: canvas.toDataURL("image/jpeg", 0.9), canvas };
    }

    function cleanOcrText(t) {
      let s = (t || "");
      s = s.replace(/[^\S\r\n]+/g, " ");
      s = s.replace(/\n{3,}/g, "\n\n");
      s = s.replace(/[|}{]{2,}/g, " ");
      s = s.replace(/[^\p{L}\p{N}\s.,:;!?()+\-\/€$@%]/gu, "");
      s = s.replace(/\s{2,}/g, " ").trim();
      return s;
    }

    async function runTesseractOnDataUrl(dataUrl, statusPrefix) {
      const lang = "deu+rus+ukr";
      const { data } = await Tesseract.recognize(dataUrl, lang, {
        logger: (m) => {
          if (m && m.status === "recognizing text" && typeof m.progress === "number") {
            const pct = Math.round(m.progress * 100);
            statusBox.textContent = `${statusPrefix} ${pct}%`;
          }
        }
      });
      const raw = (data && data.text) ? data.text : "";
      return cleanOcrText(raw);
    }

    // --- PDF helpers (parse + OCR fallback) ---
    async function openPdfNoWorker(file) {
      const buf = await file.arrayBuffer();
      // disableWorker:true — критично для Telegram WebView
      return await pdfjsLib.getDocument({ data: buf, disableWorker: true }).promise;
    }

    async function extractTextFromPdf(pdf, maxPages = 3) {
      const total = pdf.numPages;
      const pages = Math.min(total, maxPages);
      let textAll = "";

      for (let i = 1; i <= pages; i++) {
        statusBox.textContent = TEXTS[currentLang].status_pdf_page(i, pages);
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const strings = content.items
          .map(it => (it && it.str) ? it.str : "")
          .filter(Boolean);
        textAll += strings.join(" ") + "\n\n";
      }
      return textAll.trim();
    }

    async function ocrFirstPdfPage(pdf) {
      const pageNum = 1;
      statusBox.textContent = TEXTS[currentLang].status_pdf_ocr_page(pageNum);

      const page = await pdf.getPage(pageNum);
      // scale 2 — читаемее, но не слишком тяжело
      const viewport = page.getViewport({ scale: 2.0 });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);

      await page.render({ canvasContext: ctx, viewport }).promise;

      const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
      const cleaned = await runTesseractOnDataUrl(dataUrl, "PDF → OCR…");
      return cleaned;
    }

    function resetUi() {
      fileInfo.textContent = "";
      imagePreview.style.display = "none";
      imagePreview.src = "";
      imagePreview.alt = "";

      tipsBox.style.display = "none";

      ocrBtn.style.display = "none";
      pdfBtn.style.display = "none";

      statusBox.style.display = "none";
      statusBox.textContent = "";

      resultBox.style.display = "none";

      lastDownscaledCanvas = null;
    }

    // Events
    btnRu.addEventListener("click", () => setLang("ru"));
    btnUa.addEventListener("click", () => setLang("ua"));
    uploadBtn.addEventListener("click", () => fileInput.click());

    textInput.addEventListener("input", () => scheduleAutoAnalyze());
    analyzeBtn.addEventListener("click", () => runAnalyzeNow());

    fileInput.addEventListener("change", async () => {
      resetUi();

      const file = fileInput.files && fileInput.files[0];
      if (!file) return;

      currentFile = file;

      const kb = Math.round(file.size / 1024);
      const mime = (file.type || "").toLowerCase();
      const isPdf = mime === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
      const isImage = mime.startsWith("image/");
      const typeLabel = mime ? mime : "unknown";

      fileInfo.textContent = TEXTS[currentLang].fileInfo(file.name, kb, typeLabel);

      if (isPdf) {
        currentKind = "pdf";
        statusBox.style.display = "block";
        statusBox.textContent = TEXTS[currentLang].pickedPdf;
        pdfBtn.style.display = "block";
        return;
      }

      if (isImage) {
        currentKind = "image";

        const url = URL.createObjectURL(file);
        imagePreview.src = url;
        imagePreview.alt = file.name;
        imagePreview.style.display = "block";

        tipsBox.style.display = "block";

        statusBox.style.display = "block";
        statusBox.textContent = TEXTS[currentLang].pickedImage;

        ocrBtn.style.display = "block";

        try {
          const r = await downscaleImageToDataUrl(file, 1600);
          lastDownscaledCanvas = r.canvas;
        } catch (e) {}
        return;
      }

      currentKind = null;
      statusBox.style.display = "block";
      statusBox.textContent = TEXTS[currentLang].unknownType;
    });

    ocrBtn.addEventListener("click", async () => {
      if (!currentFile || currentKind !== "image") return;

      try {
        ocrBtn.disabled = true;
        statusBox.style.display = "block";
        statusBox.textContent = TEXTS[currentLang].status_ocr_working(0);

        let dataUrl;
        if (lastDownscaledCanvas) dataUrl = lastDownscaledCanvas.toDataURL("image/jpeg", 0.9);
        else dataUrl = (await downscaleImageToDataUrl(currentFile, 1600)).dataUrl;

        const cleaned = await runTesseractOnDataUrl(dataUrl, "OCR…");
        if (cleaned.length > 0) {
          textInput.value = cleaned;
          statusBox.textContent = TEXTS[currentLang].status_ocr_done;
          runAnalyzeNow(); // авто-анализ после OCR
        } else {
          statusBox.textContent = TEXTS[currentLang].status_ocr_fail;
        }
      } catch (e) {
        statusBox.textContent = TEXTS[currentLang].status_ocr_fail;
      } finally {
        ocrBtn.disabled = false;
      }
    });

    pdfBtn.addEventListener("click", async () => {
      if (!currentFile || currentKind !== "pdf") return;

      pdfBtn.disabled = true;
      statusBox.style.display = "block";
      statusBox.textContent = TEXTS[currentLang].status_pdf_loading;

      try {
        let pdf;
        try {
          pdf = await openPdfNoWorker(currentFile);
        } catch (e) {
          // не смог даже открыть -> сразу OCR первой страницы (если получится открыть дальше — но здесь нет)
          statusBox.textContent = TEXTS[currentLang].status_pdf_fail_to_open;
          // Иногда открыть не получилось вообще — тогда честно падаем:
          throw e;
        }

        // 1) Пытаемся извлечь текст
        let extracted = "";
        try {
          extracted = await extractTextFromPdf(pdf, 3);
        } catch (e) {
          extracted = "";
        }

        if (extracted && extracted.length >= 60) {
          textInput.value = extracted;
          statusBox.textContent = TEXTS[currentLang].status_pdf_done(extracted.length);
          runAnalyzeNow(); // авто-анализ после PDF parse
          pdfBtn.disabled = false;
          return;
        }

        // 2) Если текста мало/нет — OCR первой страницы
        statusBox.textContent = TEXTS[currentLang].status_pdf_empty;

        const ocrText = await ocrFirstPdfPage(pdf);
        if (ocrText && ocrText.length >= 40) {
          textInput.value = ocrText;
          statusBox.textContent = TEXTS[currentLang].status_pdf_ocr_done;
          runAnalyzeNow(); // авто-анализ после PDF OCR
        } else {
          statusBox.textContent = TEXTS[currentLang].status_pdf_all_fail;
        }

      } catch (e) {
        // Если даже открыть PDF не смогли — fallback: попросить фото
        statusBox.textContent = TEXTS[currentLang].status_pdf_all_fail;
      } finally {
        pdfBtn.disabled = false;
      }
    });

    // init
    setLang("ru");
  </script>
</body>
</html>
