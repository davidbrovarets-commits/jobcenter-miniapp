<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Jobcenter Letter Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />

  <style>
    /* Минимальные стили для карусели/индикатора (не ломают твой style.css) */
    .actionsRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .actionsRow .btn{flex:1; min-width:180px;}
    .muted{opacity:0.9}
    .chip{display:inline-block; padding:6px 10px; border-radius:999px; background:rgba(0,0,0,0.12); font-size:12px; opacity:0.95}
    .carouselWrap{margin-top:12px; display:none;}
    .carouselHeader{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px;}
    .carousel{
      display:flex; gap:10px; overflow-x:auto; padding-bottom:8px;
      scroll-snap-type:x mandatory; -webkit-overflow-scrolling:touch;
    }
    .slide{
      scroll-snap-align:start;
      flex:0 0 220px;
      background:rgba(0,0,0,0.10);
      border-radius:14px;
      padding:10px;
      border:2px solid transparent;
      position:relative;
    }
    .slide.bad{border-color:rgba(255,0,0,0.75);}
    .slide img{width:100%; height:150px; object-fit:cover; border-radius:12px; display:block;}
    .slideMeta{margin-top:8px; display:flex; justify-content:space-between; align-items:center; gap:8px;}
    .slideMeta .pageNo{font-weight:700; font-size:13px;}
    .delBtn{
      border:none; background:rgba(0,0,0,0.18); color:inherit;
      border-radius:10px; padding:6px 10px; cursor:pointer; opacity:0.95;
    }
    .delBtn:disabled{opacity:0.4; cursor:not-allowed;}
    .badNote{margin-top:8px; font-size:12px; color:rgba(255,120,120,1); display:none; white-space:pre-wrap;}
    .slide.bad .badNote{display:block;}

    .progressBox{display:none; margin-top:12px; padding:12px; border-radius:14px; background:rgba(0,0,0,0.12);}
    .progressRow{display:flex; align-items:center; gap:12px;}
    .ring{
      width:26px; height:26px; border-radius:50%;
      border:3px solid rgba(255,255,255,0.22);
      border-top-color: rgba(255,255,255,0.85);
      animation: spin 0.9s linear infinite;
      flex:0 0 auto;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .progressText{line-height:1.25}
    .progressText .t1{font-weight:800}
    .progressText .t2{opacity:0.95; margin-top:2px}
    .lockNote{margin-top:8px; font-size:12px; opacity:0.9}

    .hintBox{margin-top:10px; padding:10px 12px; border-radius:14px; background:rgba(0,0,0,0.10); display:none;}
  </style>
</head>

<body>
  <div class="app">
    <h1 id="title">Проверка письма Jobcenter</h1>
    <p id="subtitle">Помогаем понять, требуется ли действие по письму.</p>

    <div class="card">
      <p id="disclaimer">
        Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.
      </p>

      <!-- 2 режима добавления: камера и выбор файлов -->
      <div class="actionsRow">
        <button id="cameraBtn" class="btn" type="button">Сделать фото</button>
        <button id="filesBtn" class="btn" type="button">Выбрать файлы</button>
      </div>

      <!-- Скрытые инпуты -->
      <input id="cameraInput" type="file" accept="image/*" capture="environment" style="display:none" />
      <input id="filesInput" type="file" accept="image/*" multiple style="display:none" />

      <!-- Карусель -->
      <div id="carouselWrap" class="carouselWrap">
        <div class="carouselHeader">
          <div class="chip" id="pagesCount">Добавлено: 0</div>
          <div class="chip" id="pageIndex">Страница: 0 / 0</div>
        </div>
        <div id="carousel" class="carousel"></div>
      </div>

      <!-- Подсказка при 0 страниц -->
      <div id="zeroHint" class="hintBox">
        Для анализа, пожалуйста, добавьте файл.
      </div>

      <!-- Кнопка финального запуска -->
      <button id="analyzeBtn" class="btn" type="button" style="margin-top:12px; width:100%;" disabled>
        Готово → Анализ
      </button>

      <!-- Прогресс -->
      <div id="progressBox" class="progressBox">
        <div class="progressRow">
          <div class="ring" aria-hidden="true"></div>
          <div class="progressText">
            <div id="pLine1" class="t1">Анализ идёт</div>
            <div id="pLine2" class="t2">Контролируем содержание письма</div>
          </div>
        </div>
        <div id="lockNote" class="lockNote">
          Во время анализа добавление и удаление страниц временно недоступны.
        </div>
      </div>

      <!-- Результат -->
      <div id="resultBox" style="display:none; margin-top:12px; padding:12px; border-radius:14px; background:rgba(0,0,0,0.12);">
        <div id="doneBanner" style="display:none; margin-bottom:10px;">
          <div style="font-weight:800;">Анализ завершён</div>
          <div style="opacity:0.95; margin-top:2px;">Ниже — результат проверки письма</div>
        </div>

        <div id="resultTitle" style="font-weight:800; margin-bottom:6px;"></div>
        <div id="resultSupport" style="margin-bottom:10px; opacity:0.95;"></div>
        <div id="resultDetails" style="white-space:pre-wrap; opacity:0.95;"></div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.14);">
          <div style="font-weight:800; margin-bottom:6px;">Кратко о письме</div>
          <div id="aboutText" style="white-space:pre-wrap; opacity:0.95;"></div>
        </div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.14);">
          <div style="font-weight:800; margin-bottom:6px;">Перевод (будет позже)</div>
          <div style="white-space:pre-wrap; opacity:0.95;">
Сделаем так: независимо от результата будет понятный перевод и объяснение письма.
Подключим AI на следующем этапе (после стабилизации входа и многостраничности).
          </div>
        </div>
      </div>

      <small class="version" style="display:block; margin-top:12px; opacity:0.85;">
        v1.2 · Multi-page images + carousel preview + quality marking + ring progress + fixed microcopy
      </small>
    </div>
  </div>

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // Telegram init (safe)
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg) { tg.ready(); tg.expand(); }

    // DOM
    const cameraBtn = document.getElementById("cameraBtn");
    const filesBtn  = document.getElementById("filesBtn");
    const cameraInput = document.getElementById("cameraInput");
    const filesInput  = document.getElementById("filesInput");

    const carouselWrap = document.getElementById("carouselWrap");
    const carousel = document.getElementById("carousel");
    const pagesCount = document.getElementById("pagesCount");
    const pageIndex = document.getElementById("pageIndex");

    const analyzeBtn = document.getElementById("analyzeBtn");
    const zeroHint = document.getElementById("zeroHint");

    const progressBox = document.getElementById("progressBox");
    const pLine1 = document.getElementById("pLine1");
    const pLine2 = document.getElementById("pLine2");

    const resultBox = document.getElementById("resultBox");
    const doneBanner = document.getElementById("doneBanner");
    const resultTitle = document.getElementById("resultTitle");
    const resultSupport = document.getElementById("resultSupport");
    const resultDetails = document.getElementById("resultDetails");
    const aboutText = document.getElementById("aboutText");

    // State
    const pages = []; // {id, file, thumbUrl, fullUrl, bad:false, badReason:"", ocrText:"", ocrConfidence:null}
    let isLocked = false;

    // ---------- Helpers ----------
    function uid() {
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    function setLocked(v) {
      isLocked = v;
      cameraBtn.disabled = v;
      filesBtn.disabled = v;
      analyzeBtn.disabled = v || pages.length === 0;

      // блокируем кнопки удаления
      carousel.querySelectorAll("button[data-del]").forEach(btn => btn.disabled = v);
    }

    function showZeroHintIfNeeded() {
      if (pages.length === 0) {
        zeroHint.style.display = "block";
        analyzeBtn.disabled = true;
      } else {
        zeroHint.style.display = "none";
        analyzeBtn.disabled = isLocked;
      }
    }

    function updateCounters() {
      pagesCount.textContent = "Добавлено: " + pages.length;
      if (pages.length === 0) {
        pageIndex.textContent = "Страница: 0 / 0";
      } else {
        // определяем текущую страницу по scroll
        const idx = getVisibleIndex();
        pageIndex.textContent = "Страница: " + (idx + 1) + " / " + pages.length;
      }
    }

    function getVisibleIndex() {
      if (!pages.length) return 0;
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      if (!slides.length) return 0;
      const left = carousel.scrollLeft;
      let best = 0;
      let bestDist = Infinity;
      slides.forEach((s, i) => {
        const dist = Math.abs(s.offsetLeft - left);
        if (dist < bestDist) { bestDist = dist; best = i; }
      });
      return best;
    }

    function renderCarousel() {
      carousel.innerHTML = "";
      if (pages.length === 0) {
        carouselWrap.style.display = "none";
        showZeroHintIfNeeded();
        updateCounters();
        return;
      }

      carouselWrap.style.display = "block";
      showZeroHintIfNeeded();

      pages.forEach((p, idx) => {
        const slide = document.createElement("div");
        slide.className = "slide" + (p.bad ? " bad" : "");
        slide.dataset.id = p.id;

        const img = document.createElement("img");
        img.src = p.thumbUrl;
        img.alt = "Страница " + (idx + 1);

        const meta = document.createElement("div");
        meta.className = "slideMeta";

        const pageNo = document.createElement("div");
        pageNo.className = "pageNo";
        pageNo.textContent = "Стр. " + (idx + 1);

        const del = document.createElement("button");
        del.className = "delBtn";
        del.type = "button";
        del.textContent = "Удалить";
        del.dataset.del = p.id;
        del.disabled = isLocked;
        del.addEventListener("click", () => {
          if (isLocked) return;
          removePage(p.id);
        });

        meta.appendChild(pageNo);
        meta.appendChild(del);

        const badNote = document.createElement("div");
        badNote.className = "badNote";
        badNote.textContent = p.badReason || "Обнаружена плохо читаемая страница. Рекомендуем заменить для точного результата.";

        slide.appendChild(img);
        slide.appendChild(meta);
        slide.appendChild(badNote);

        carousel.appendChild(slide);
      });

      updateCounters();
    }

    function removePage(id) {
      const i = pages.findIndex(p => p.id === id);
      if (i >= 0) {
        // освобождаем blob url
        try { URL.revokeObjectURL(pages[i].thumbUrl); } catch(e) {}
        try { URL.revokeObjectURL(pages[i].fullUrl); } catch(e) {}
        pages.splice(i, 1);
      }
      renderCarousel();
    }

    async function createThumbAndFull(file) {
      // Создаём blob URLs (быстро). Для OCR будем работать с canvas downscale.
      const fullUrl = URL.createObjectURL(file);
      // Для превью используем тот же blob url (можно отдельно — но достаточно)
      const thumbUrl = fullUrl;
      return { thumbUrl, fullUrl };
    }

    async function addFiles(fileList) {
      const arr = Array.from(fileList || []);
      if (!arr.length) return;
      // Добавляем в порядке выбора
      for (const f of arr) {
        if (!f || !f.type || !f.type.startsWith("image/")) continue;
        const { thumbUrl, fullUrl } = await createThumbAndFull(f);
        pages.push({
          id: uid(),
          file: f,
          thumbUrl,
          fullUrl,
          bad: false,
          badReason: "",
          ocrText: "",
          ocrConfidence: null
        });
      }
      // Сброс input, чтобы можно было выбрать те же файлы снова
      cameraInput.value = "";
      filesInput.value = "";
      // Скрываем результат при новом добавлении
      resultBox.style.display = "none";
      doneBanner.style.display = "none";
      renderCarousel();
    }

    // OCR helpers
    async function downscaleToDataUrl(file, maxSide = 1800) {
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.src = url;

      await new Promise((res, rej) => {
        img.onload = () => res();
        img.onerror = () => rej(new Error("Image load failed"));
      });

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      const scale = Math.min(1, maxSide / Math.max(w, h));
      const nw = Math.max(1, Math.round(w * scale));
      const nh = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement("canvas");
      canvas.width = nw;
      canvas.height = nh;
      const ctx = canvas.getContext("2d", { willReadFrequently: false });
      ctx.drawImage(img, 0, 0, nw, nh);

      URL.revokeObjectURL(url);
      return canvas.toDataURL("image/jpeg", 0.9);
    }

    function cleanOcrText(t) {
      let s = (t || "");
      s = s.replace(/[^\S\r\n]+/g, " ");
      s = s.replace(/\n{3,}/g, "\n\n");
      s = s.replace(/[|}{]{2,}/g, " ");
      s = s.replace(/[^\p{L}\p{N}\s.,:;!?()+\-\/€$@%]/gu, "");
      s = s.replace(/\s{2,}/g, " ").trim();
      return s;
    }

    async function ocrOnePage(pageObj, idx, total) {
      // Микротексты (наша спецификация)
      pLine1.textContent = "Анализ идёт";
      // динамика по шагам
      if (total > 1) {
        pLine2.textContent = "Обрабатываем страницы: " + (idx + 1) + " из " + total;
      } else {
        pLine2.textContent = "Обрабатываем все страницы письма";
      }

      const dataUrl = await downscaleToDataUrl(pageObj.file, 1800);

      const { data } = await Tesseract.recognize(dataUrl, "deu+rus", {
        logger: (m) => {
          // не показываем проценты (по нашей психологии), но можно слегка менять текст
          // оставляем минимально.
        }
      });

      const rawText = (data && data.text) ? data.text : "";
      const cleaned = cleanOcrText(rawText);
      const confidence = (data && typeof data.confidence === "number") ? data.confidence : null;

      pageObj.ocrText = cleaned;
      pageObj.ocrConfidence = confidence;

      // оценка качества (простая, но практичная)
      // 1) очень мало текста
      // 2) низкая confidence
      const tooShort = cleaned.length < 40;
      const lowConf = (confidence !== null && confidence < 55);

      if (tooShort || lowConf) {
        pageObj.bad = true;
        let reason = "Обнаружена плохо читаемая страница. Рекомендуем заменить для точного результата.";
        if (tooShort && lowConf) reason = "Страница читается плохо (мало текста и низкое качество распознавания). Рекомендуем переснять/заменить.";
        else if (tooShort) reason = "На странице почти не удалось распознать текст. Рекомендуем переснять/заменить.";
        else if (lowConf) reason = "Качество распознавания низкое. Рекомендуем переснять/заменить для точного результата.";
        pageObj.badReason = reason;
      } else {
        pageObj.bad = false;
        pageObj.badReason = "";
      }
    }

    // Analysis (rule-based)
    function normalize(s) {
      return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
    }
    function findDeadline(text) {
      const m1 = text.match(/\b(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m1) return m1[1];
      const m2 = text.match(/\b(bis zum|spätestens am|frist|fristen|bis spätestens)\s+(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m2) return m2[2];
      return "";
    }
    function analyzeText(raw) {
      const t = normalize(raw);
      if (t.length < 60) return { kind: "unclear", deadline: "" };

      const actionSignals = [
        "bitte","wir bitten","sie werden gebeten","sie sind verpflichtet",
        "erforderlich","nachweisen","nachweis","einreichen","vorlegen",
        "termin","einladung","melden sie sich","rückmeldung",
        "frist","bis zum","spätestens","umgehend","sofort",
        "anhörung","mitwirkung","aufforderung","fehlende unterlagen",
        "unterlagen","kontoauszüge","mietvertrag","ausfüllen","formular"
      ];
      const infoSignals = [
        "bewilligung","bescheid","änderungsbescheid","mitteilung","information",
        "zahlung","auszahlung","überweisung","betrag",
        "wir informieren","zur kenntnis","hinweis","bewilligungsbescheid",
        "veränderungsmitteilung"
      ];

      let actionScore = 0, infoScore = 0;
      for (const w of actionSignals) if (t.includes(w)) actionScore++;
      for (const w of infoSignals) if (t.includes(w)) infoScore++;

      const deadline = findDeadline(t);

      if (actionScore >= 2 || (actionScore >= 1 && (t.includes("frist") || t.includes("termin") || deadline))) {
        return { kind: "needAction", deadline };
      }
      if (infoScore >= 2 && actionScore === 0) return { kind: "noAction", deadline: "" };
      return { kind: "unclear", deadline: "" };
    }

    function explainLetter(raw) {
      const t = normalize(raw);
      if (t.length < 60) return "Пока мало текста. Добавьте/переснимите страницу с основной частью (где Bitte / Frist / Termin).";

      const hasTermin = /termin|einladung|melden sie sich|vorsprechen/.test(t);
      const hasDocs = /unterlagen|nachweis|nachweisen|einreichen|vorlegen|mitwirkung|aufforderung|fehlende|ausfüllen|formular/.test(t);
      const hasPay = /bürgergeld|zahlung|auszahlung|betrag|überweisung|monatlich/.test(t);
      const hasBescheid = /bescheid|änderungsbescheid|bewilligung|bewilligungsbescheid|mitteilung|veränderungsmitteilung/.test(t);

      if (hasTermin) return "Похоже на приглашение/термин. Обычно требуется действие: прийти/ответить.";
      if (hasDocs) return "Похоже на запрос документов/содействие. Обычно требуется действие: предоставить/дослать.";
      if (hasPay) return "Похоже на письмо о выплате/суммах. Часто это информирование.";
      if (hasBescheid) return "Похоже на решение/уведомление (Bescheid). Проверьте, есть ли просьба/срок.";
      return "Тип письма пока неясен. Обратите внимание на слова Bitte / Frist / Termin.";
    }

    function showResult(res, combinedText) {
      // Баннер "Анализ завершён"
      doneBanner.style.display = "block";

      // Заголовки + поддержка по спецификации
      resultSupport.textContent = "";
      if (res.kind === "needAction") {
        resultTitle.textContent = "✅ Требуется действие";
        resultSupport.textContent = "Это нормально. Ниже — пояснение, что именно требуется.";
        resultDetails.textContent =
          "Похоже, Jobcenter ожидает от вас действие.\n" +
          (res.deadline ? ("Возможный срок: " + res.deadline + "\n") : "") +
          "Проверьте: просят ли предоставить документы, заполнить форму или прийти в термин.\n\n" +
          "Совет: если видите слова Bitte / Frist / Termin — это почти всегда сигнал к действию.";
      } else if (res.kind === "noAction") {
        resultTitle.textContent = "❌ Действие не требуется (скорее всего)";
        resultSupport.textContent = "Это информационное письмо. Обычно в таком случае никаких действий не требуется.";
        resultDetails.textContent =
          "Похоже, письмо носит информационный характер (уведомление/решение/суммы).\n" +
          "Если нет просьбы прислать документы, прийти в термин или ответить — обычно действия не требуется.";
      } else {
        resultTitle.textContent = "⚠️ Неясно — нужна проверка";
        resultSupport.textContent = "В письме есть неоднозначные формулировки. Ниже — на что стоит обратить внимание.";
        resultDetails.textContent =
          "Сигналы неочевидны.\n" +
          "Для точности нужна страница с основной частью письма (где указаны Bitte / Frist / Termin / Unterlagen).\n" +
          "Если какая-то страница отмечена красной рамкой — лучше переснять её.";
      }

      aboutText.textContent = explainLetter(combinedText);
      resultBox.style.display = "block";
    }

    // ---------- Events ----------
    cameraBtn.addEventListener("click", () => {
      if (isLocked) return;
      cameraInput.click();
    });

    filesBtn.addEventListener("click", () => {
      if (isLocked) return;
      filesInput.click();
    });

    cameraInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(cameraInput.files);
    });

    filesInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(filesInput.files);
    });

    carousel.addEventListener("scroll", () => {
      // обновляем индикатор страницы при пролистывании
      updateCounters();
    });

    analyzeBtn.addEventListener("click", async () => {
      if (isLocked) return;
      if (pages.length === 0) {
        showZeroHintIfNeeded();
        return;
      }

      // Старт анализа: блокируем
      setLocked(true);
      // Сброс результата
      resultBox.style.display = "none";
      doneBanner.style.display = "none";

      // Показываем прогресс + стартовый микротекст (якорь)
      progressBox.style.display = "block";
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Контролируем содержание письма";

      // Чуть позже переключаем на "Обрабатываем все страницы"
      setTimeout(() => {
        if (!isLocked) return;
        pLine1.textContent = "Анализ идёт";
        pLine2.textContent = (pages.length > 1)
          ? ("Обрабатываем все страницы письма")
          : ("Обрабатываем все страницы письма");
      }, 900);

      try {
        // OCR по всем страницам последовательно (надёжнее, меньше лагов)
        for (let i = 0; i < pages.length; i++) {
          await ocrOnePage(pages[i], i, pages.length);
          // Обновим визуально красные рамки, если появились
          renderCarousel();
        }

        // Перед результатом — ключевой текст
        pLine1.textContent = "Анализ идёт";
        pLine2.textContent = "Проверяем, требуется ли от вас действие";

        // Склеиваем общий текст
        const combinedText = pages
          .map((p, idx) => `--- Страница ${idx + 1} ---\n${p.ocrText || ""}`)
          .join("\n\n");

        const res = analyzeText(combinedText);

        // Завершение
        pLine1.textContent = "Анализ завершён";
        pLine2.textContent = "Ниже — результат проверки письма";

        // Небольшая пауза для психологического "закрытия процесса"
        setTimeout(() => {
          showResult(res, combinedText);
          progressBox.style.display = "none";
          setLocked(false);
          showZeroHintIfNeeded();
        }, 450);

      } catch (e) {
        // На случай сбоя OCR
        progressBox.style.display = "none";
        setLocked(false);
        showZeroHintIfNeeded();

        resultBox.style.display = "block";
        doneBanner.style.display = "none";
        resultTitle.textContent = "⚠️ Не удалось завершить анализ";
        resultSupport.textContent = "Это нормально. Попробуйте ещё раз — лучше с более чёткими страницами.";
        resultDetails.textContent =
          "Рекомендации:\n" +
          "• Сделайте фото ближе (текст должен занимать 70–90% кадра)\n" +
          "• Уберите блики и тени\n" +
          "• Переснимите страницы, которые отмечены красной рамкой\n";
        aboutText.textContent = "—";
      }
    });

    // init
    renderCarousel();
    showZeroHintIfNeeded();
  </script>
</body>
</html>
