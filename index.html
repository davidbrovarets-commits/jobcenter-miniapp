<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Jobcenter Letter Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="app">
    <h1 id="title">Проверка письма Jobcenter</h1>
    <p id="subtitle">Помогаем понять, требуется ли действие по письму.</p>

    <div class="card">
      <p id="disclaimer">
        Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.
      </p>

      <div class="actionsRow">
        <button id="cameraBtn" class="btn" type="button">Сделать фото</button>
        <button id="filesBtn"  class="btn" type="button">Выбрать файлы</button>
      </div>

      <div class="smallNote">
        <b>Важно:</b> PDF в Telegram Mini App часто не обрабатывается.
        Для надёжного результата используйте фото/скрин страниц письма.<br>
        <b>Лимит:</b> максимум 15 страниц за один анализ.
      </div>

      <input id="cameraInput" type="file" accept="image/*" capture="environment" style="display:none" />
      <input id="filesInput"  type="file" accept="image/*" multiple style="display:none" />

      <!-- Карусель -->
      <div id="carouselWrap" class="carouselWrap">
        <div class="carouselHeader">
          <div class="chip" id="pagesCount">Добавлено: 0</div>
          <div class="chip" id="pageIndex">Страница: 0 / 0</div>
        </div>
        <div id="carousel" class="carousel"></div>
      </div>

      <!-- Подсказка при 0 страниц -->
      <div id="zeroHint" class="hintBox">
        Для анализа, пожалуйста, добавьте файл.
      </div>

      <!-- Панель качества (bad/warn) -->
      <div id="qualityGate" class="panel">
        <div id="qualityTitle" class="panelTitle">Проверка качества страниц</div>
        <div id="qualityText" class="panelText"></div>

        <div class="panelActions">
          <button id="showBadBtn" class="btn" type="button">Показать нечитаемые</button>
          <button id="deleteBadBtn" class="btn" type="button">Удалить нечитаемые</button>
          <button id="showWarnBtn" class="btn" type="button">Показать частично распознанные</button>
        </div>

        <div class="smallNote">
          Плохие страницы блокируют анализ. Частично распознанные страницы не блокируют, но могут снизить точность.
        </div>
      </div>

      <!-- Кнопка запуска -->
      <button id="analyzeBtn" class="btn btnPrimary" type="button" disabled>
        Готово → Анализ
      </button>

      <!-- Прогресс -->
      <div id="progressBox" class="progressBox">
        <div class="progressRow">
          <div class="ring" aria-hidden="true"></div>
          <div class="progressText">
            <div id="pLine1" class="t1">Анализ идёт</div>
            <div id="pLine2" class="t2">Контролируем содержание письма</div>
          </div>
        </div>
        <div class="lockNote">
          Во время анализа добавление и удаление страниц временно недоступны.
        </div>
      </div>

      <!-- Результат -->
      <div id="resultBox" class="panel">
        <div id="doneBanner" style="display:none; margin-bottom:10px;">
          <div style="font-weight:800;">Анализ завершён</div>
          <div style="opacity:0.95; margin-top:2px;">Ниже — результат проверки письма</div>
        </div>

        <div id="resultTitle" class="panelTitle"></div>
        <div id="resultSupport" class="panelText" style="margin-bottom:10px;"></div>
        <div id="resultDetails" class="panelText"></div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.14);">
          <div class="panelTitle">Кратко о письме</div>
          <div id="aboutText" class="panelText"></div>
        </div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.14);">
          <div class="panelTitle">Перевод (следующий этап)</div>
          <div class="panelText">
            Независимо от результата мы добавим понятный перевод и объяснение письма.
            Это будет подключено на следующем этапе через AI (после стабилизации входа и многостраничности).
          </div>
        </div>
      </div>

      <small class="version">
        v1.5 · thumbnails + ocrBlob · warn/bad · quality gate A · single worker · yield · no full rerender
      </small>
    </div>
  </div>

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // Telegram init (safe)
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg) { tg.ready(); tg.expand(); }

    // ---------------- DOM ----------------
    const cameraBtn = document.getElementById("cameraBtn");
    const filesBtn  = document.getElementById("filesBtn");
    const cameraInput = document.getElementById("cameraInput");
    const filesInput  = document.getElementById("filesInput");

    const carouselWrap = document.getElementById("carouselWrap");
    const carousel = document.getElementById("carousel");
    const pagesCount = document.getElementById("pagesCount");
    const pageIndex = document.getElementById("pageIndex");

    const analyzeBtn = document.getElementById("analyzeBtn");
    const zeroHint = document.getElementById("zeroHint");

    const progressBox = document.getElementById("progressBox");
    const pLine1 = document.getElementById("pLine1");
    const pLine2 = document.getElementById("pLine2");

    const qualityGate = document.getElementById("qualityGate");
    const qualityTitle = document.getElementById("qualityTitle");
    const qualityText = document.getElementById("qualityText");
    const showBadBtn = document.getElementById("showBadBtn");
    const deleteBadBtn = document.getElementById("deleteBadBtn");
    const showWarnBtn = document.getElementById("showWarnBtn");

    const resultBox = document.getElementById("resultBox");
    const doneBanner = document.getElementById("doneBanner");
    const resultTitle = document.getElementById("resultTitle");
    const resultSupport = document.getElementById("resultSupport");
    const resultDetails = document.getElementById("resultDetails");
    const aboutText = document.getElementById("aboutText");

    // ---------------- State ----------------
    const MAX_PAGES = 15;

    // pages: { id, thumbUrl, ocrBlob, bad, badReason, warn, warnReason, ocrText, ocrConfidence }
    const pages = [];
    let isLocked = false;

    let ocrWorker = null;

    // ---------------- Helpers ----------------
    function uid() {
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    function nextFrame() {
      return new Promise(r => requestAnimationFrame(() => r()));
    }

    function normalize(s) {
      return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
    }

    function hasBadPages() {
      return pages.some(p => p.bad);
    }

    function hasWarnPages() {
      return pages.some(p => p.warn && !p.bad);
    }

    function badIndexes() {
      return pages.map((p,i)=>p.bad ? (i+1) : null).filter(Boolean);
    }

    function warnIndexes() {
      return pages.map((p,i)=> (p.warn && !p.bad) ? (i+1) : null).filter(Boolean);
    }

    function firstBadIndex() {
      return pages.findIndex(p => p.bad);
    }

    function firstWarnIndex() {
      return pages.findIndex(p => p.warn && !p.bad);
    }

    function setLocked(v) {
      isLocked = v;
      cameraBtn.disabled = v;
      filesBtn.disabled = v;

      // блокируем кнопки удаления на слайдах
      carousel.querySelectorAll("button[data-del]").forEach(btn => btn.disabled = v);

      // Анализ: только если есть страницы и нет bad
      analyzeBtn.disabled = v || pages.length === 0 || hasBadPages();

      // Также обновим панель качества (чтобы кнопки не "умирали")
      updateQualityPanel();
    }

    function showZeroHintIfNeeded() {
      zeroHint.style.display = (pages.length === 0) ? "block" : "none";
      analyzeBtn.disabled = isLocked || pages.length === 0 || hasBadPages();
    }

    function getVisibleIndex() {
      if (!pages.length) return 0;
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      if (!slides.length) return 0;
      const left = carousel.scrollLeft;
      let best = 0;
      let bestDist = Infinity;
      slides.forEach((s, i) => {
        const dist = Math.abs(s.offsetLeft - left);
        if (dist < bestDist) { bestDist = dist; best = i; }
      });
      return best;
    }

    function updateCounters() {
      pagesCount.textContent = "Добавлено: " + pages.length;
      if (pages.length === 0) {
        pageIndex.textContent = "Страница: 0 / 0";
      } else {
        const idx = getVisibleIndex();
        pageIndex.textContent = "Страница: " + (idx + 1) + " / " + pages.length;
      }
    }

    function scrollToPage(index) {
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      const s = slides[index];
      if (!s) return;
      carousel.scrollTo({ left: s.offsetLeft, behavior: "smooth" });
    }

    function removePage(id) {
      const i = pages.findIndex(p => p.id === id);
      if (i >= 0) {
        try { URL.revokeObjectURL(pages[i].thumbUrl); } catch(e) {}
        // ocrBlob release by GC
        pages.splice(i, 1);
      }
      renderCarousel();
      updateQualityPanel();
      resultBox.style.display = "none";
      progressBox.style.display = "none";
      showZeroHintIfNeeded();
    }

    // ---------------- Image prep: thumbnails + ocrBlob ----------------
    function loadImageFromFile(file) {
      return new Promise((res, rej) => {
        const img = new Image();
        const url = URL.createObjectURL(file);
        img.onload = () => { try { URL.revokeObjectURL(url); } catch(e) {} ; res(img); };
        img.onerror = () => { try { URL.revokeObjectURL(url); } catch(e) {} ; rej(new Error("Image load failed")); };
        img.src = url;
      });
    }

    function canvasToBlob(canvas, quality) {
      return new Promise((res) => {
        canvas.toBlob((b) => res(b), "image/jpeg", quality);
      });
    }

    async function resizeToBlob(img, maxSide, quality) {
      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      const scale = Math.min(1, maxSide / Math.max(w, h));
      const nw = Math.max(1, Math.round(w * scale));
      const nh = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement("canvas");
      canvas.width = nw;
      canvas.height = nh;
      const ctx = canvas.getContext("2d", { willReadFrequently: false });
      ctx.drawImage(img, 0, 0, nw, nh);

      return await canvasToBlob(canvas, quality);
    }

    async function createThumbAndOcr(file) {
      const img = await loadImageFromFile(file);

      // thumb (light)
      const thumbBlob = await resizeToBlob(img, 650, 0.75);
      const thumbUrl = URL.createObjectURL(thumbBlob);

      // ocr (mid)
      const ocrBlob = await resizeToBlob(img, 1800, 0.82);

      return { thumbUrl, ocrBlob };
    }

    async function addFiles(fileList) {
      const arr = Array.from(fileList || []);
      if (!arr.length) return;

      for (const f of arr) {
        if (!f || !f.type || !f.type.startsWith("image/")) continue;

        if (pages.length >= MAX_PAGES) {
          // мягко игнорируем лишние
          break;
        }

        const { thumbUrl, ocrBlob } = await createThumbAndOcr(f);

        pages.push({
          id: uid(),
          thumbUrl,
          ocrBlob,
          bad: false,
          badReason: "",
          warn: false,
          warnReason: "",
          ocrText: "",
          ocrConfidence: null
        });
      }

      cameraInput.value = "";
      filesInput.value = "";

      // скрываем панели при новом добавлении
      resultBox.style.display = "none";
      progressBox.style.display = "none";

      renderCarousel();
      updateQualityPanel();
      showZeroHintIfNeeded();
    }

    // ---------------- Carousel render ----------------
    function renderCarousel() {
      carousel.innerHTML = "";

      if (pages.length === 0) {
        carouselWrap.style.display = "none";
        updateCounters();
        return;
      }

      carouselWrap.style.display = "block";

      pages.forEach((p, idx) => {
        const slide = document.createElement("div");
        slide.className = "slide";
        if (p.bad) slide.classList.add("bad");
        else if (p.warn) slide.classList.add("warn");
        slide.dataset.id = p.id;

        const img = document.createElement("img");
        img.src = p.thumbUrl;
        img.alt = "Страница " + (idx + 1);

        const meta = document.createElement("div");
        meta.className = "slideMeta";

        const pageNo = document.createElement("div");
        pageNo.className = "pageNo";
        pageNo.textContent = "Стр. " + (idx + 1);

        const del = document.createElement("button");
        del.className = "delBtn";
        del.type = "button";
        del.textContent = "Удалить";
        del.dataset.del = p.id;
        del.disabled = isLocked;
        del.addEventListener("click", () => {
          if (isLocked) return;
          removePage(p.id);
        });

        meta.appendChild(pageNo);
        meta.appendChild(del);

        const badNote = document.createElement("div");
        badNote.className = "badNote";
        badNote.textContent = p.badReason || "Качество распознавания низкое. Переснимите или удалите страницу.";

        const warnNote = document.createElement("div");
        warnNote.className = "warnNote";
        warnNote.textContent = p.warnReason || "Текст распознан частично. Для точности лучше переснять страницу.";

        slide.appendChild(img);
        slide.appendChild(meta);
        slide.appendChild(badNote);
        slide.appendChild(warnNote);

        carousel.appendChild(slide);
      });

      updateCounters();
    }

    // Точечное обновление слайда (без full rerender)
    function updateSlideByIndex(idx) {
      const slide = carousel.querySelectorAll(".slide")[idx];
      if (!slide) return;

      slide.classList.remove("bad", "warn");
      if (pages[idx].bad) slide.classList.add("bad");
      else if (pages[idx].warn) slide.classList.add("warn");

      const badNote = slide.querySelector(".badNote");
      if (badNote) badNote.textContent = pages[idx].badReason || "Качество распознавания низкое. Переснимите или удалите страницу.";

      const warnNote = slide.querySelector(".warnNote");
      if (warnNote) warnNote.textContent = pages[idx].warnReason || "Текст распознан частично. Для точности лучше переснять страницу.";

      const del = slide.querySelector("button[data-del]");
      if (del) del.disabled = isLocked;
    }

    // ---------------- Quality: evaluatePageQuality (PATCH 1 integrated) ----------------
    function cleanOcrText(t) {
      let s = (t || "");
      s = s.replace(/[^\S\r\n]+/g, " ");
      s = s.replace(/\n{3,}/g, "\n\n");
      s = s.replace(/[|}{]{2,}/g, " ");
      s = s.replace(/[^\p{L}\p{N}\s.,:;!?()+\-\/€$@%]/gu, "");
      s = s.replace(/\s{2,}/g, " ").trim();
      return s;
    }

    function evaluatePageQuality(text, confidence) {
      const t = text || "";
      const textLen = t.length;

      const ns = t.replace(/\s+/g, "");
      const total = Math.max(1, ns.length);
      const alphaNum = (ns.match(/[A-Za-zА-Яа-я0-9ÄÖÜäöüß]/g) || []).length;
      const alphaNumRatio = alphaNum / total;

      const low = normalize(t);

      const keyPatterns = [
        "termin","einladung","frist","bis zum","spätestens",
        "bitte","wir bitten","sie werden gebeten",
        "unterlagen","nachweis","nachweisen","einreichen","vorlegen","mitwirkung",
        "anhörung","aufforderung","fehlende unterlagen","formular","ausfüllen",
        // табличные/итоговые сигналы
        "summe","euro","leistungen","regelbedarf","mehrbedarf","bedarf"
      ];

      const hasKeySignals = keyPatterns.some(k => low.includes(k));

      const conf = (confidence !== null && typeof confidence === "number") ? confidence : null;

      // Пороги (balanced)
      const confBad = (conf !== null && conf < 50);
      const confOk  = (conf === null || conf >= 55);

      const ratioBad = (alphaNumRatio < 0.45);
      const ratioOk  = (alphaNumRatio >= 0.55);

      const tooShort = (textLen < 80);
      const veryShort = (textLen < 35);

      // 1) Совсем пусто/мусор => BAD (блок)
      if (veryShort && (confBad || ratioBad)) {
        return {
          status: "bad",
          reason: "Текста почти нет или он распознан с ошибками. Переснимите или удалите страницу.",
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      // 2) Мало текста, но качество хорошее => WARN (НЕ блокируем)
      if (tooShort && confOk && ratioOk) {
        return {
          status: "warn",
          reason: "На странице мало текста (часть листа пустая), но распознавание хорошее. Анализ возможен. Для максимальной точности можно переснять ближе к тексту.",
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      // 3) Мало текста + есть ключевые сигналы => WARN
      if (tooShort && hasKeySignals && !confBad && !ratioBad) {
        return {
          status: "warn",
          reason: "Текст распознан частично, но найдены сигналы. Анализ возможен, но для точности лучше переснять страницу.",
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      // 4) Плохая уверенность или мусор => BAD (блок)
      if (confBad || ratioBad) {
        let reason = "Качество распознавания низкое. Переснимите или удалите страницу.";
        if (confBad && ratioBad) reason = "Страница распознана плохо (низкая уверенность и много мусора). Переснимите или удалите.";
        return {
          status: "bad",
          reason,
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      // 5) Просто мало текста => WARN (не блокируем)
      if (tooShort) {
        return {
          status: "warn",
          reason: "Текста немного. Анализ возможен, но лучше добавить страницу с основной частью письма (Bitte/Frist/Termin), если она есть.",
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      return { status: "ok", reason: "", metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals } };
    }

    // ---------------- Quality Panel ----------------
    function updateQualityPanel() {
      const bad = badIndexes();
      const warn = warnIndexes();

      // скрыть если вообще нечего показывать
      if (bad.length === 0 && warn.length === 0) {
        qualityGate.style.display = "none";
        qualityText.textContent = "";
        return;
      }

      qualityGate.style.display = "block";

      // Режим BAD (жёсткий)
      if (bad.length > 0) {
        qualityTitle.textContent = "Обнаружены нечитаемые страницы";
        qualityText.textContent =
          "Нечитаемые страницы: " + bad.join(", ") + "\n" +
          "Чтобы анализ был точным, переснимите или удалите их.";

        // Кнопки
        showBadBtn.disabled = isLocked ? true : false;
        deleteBadBtn.disabled = isLocked ? true : false;

        // Warn кнопка активна только если warn есть
        showWarnBtn.disabled = (isLocked || warn.length === 0);

        // Анализ запрещён при bad
        analyzeBtn.disabled = true;
        return;
      }

      // Режим WARN (мягкий)
      qualityTitle.textContent = "Есть частично распознанные страницы";
      qualityText.textContent =
        "Частично распознанные страницы: " + warn.join(", ") + "\n" +
        "Анализ возможен, но для максимальной точности лучше переснять эти страницы.";

      showBadBtn.disabled = true;
      deleteBadBtn.disabled = true;

      showWarnBtn.disabled = isLocked ? true : false;

      // Анализ разрешён, если не залочено и есть страницы
      analyzeBtn.disabled = isLocked || pages.length === 0;
    }

    // ---------------- OCR: single worker ----------------
    async function getOcrWorker() {
      if (ocrWorker) return ocrWorker;
      ocrWorker = await Tesseract.createWorker("deu+rus");
      return ocrWorker;
    }

    async function closeOcrWorker() {
      if (!ocrWorker) return;
      try { await ocrWorker.terminate(); } catch(e) {}
      ocrWorker = null;
    }

    async function ocrOnePage(pageObj, idx, total) {
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Обрабатываем страницы: " + (idx + 1) + " из " + total;

      // OCR
      const worker = await getOcrWorker();
      const { data } = await worker.recognize(pageObj.ocrBlob);

      const rawText = (data && data.text) ? data.text : "";
      const cleaned = cleanOcrText(rawText);
      const confidence = (data && typeof data.confidence === "number") ? data.confidence : null;

      pageObj.ocrText = cleaned;
      pageObj.ocrConfidence = confidence;

      const q = evaluatePageQuality(cleaned, confidence);

      pageObj.bad = (q.status === "bad");
      pageObj.badReason = pageObj.bad ? q.reason : "";

      pageObj.warn = (q.status === "warn");
      pageObj.warnReason = pageObj.warn ? q.reason : "";
    }

    // ---------------- Rule-based analysis ----------------
    function findDeadline(text) {
      const m1 = text.match(/\b(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m1) return m1[1];
      const m2 = text.match(/\b(bis zum|spätestens am|frist|fristen|bis spätestens)\s+(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m2) return m2[2];
      return "";
    }

    function analyzeText(raw) {
      const t = normalize(raw);
      if (t.length < 100) return { kind: "insufficient", deadline: "", signals: [] };

      const signalsAction = [
        "bitte","wir bitten","sie werden gebeten","sie sind verpflichtet",
        "erforderlich","nachweisen","nachweis","einreichen","vorlegen",
        "termin","einladung","melden sie sich","rückmeldung",
        "frist","bis zum","spätestens","umgehend",
        "anhörung","mitwirkung","aufforderung","fehlende unterlagen",
        "unterlagen","kontoauszüge","mietvertrag","ausfüllen","formular"
      ];

      const found = signalsAction.filter(w => t.includes(w));
      const deadline = findDeadline(t);

      if (found.length >= 2 || (found.length >= 1 && (t.includes("frist") || t.includes("termin") || deadline))) {
        return { kind: "needAction", deadline, signals: found.slice(0, 6) };
      }

      return { kind: "noAction", deadline: "", signals: [] };
    }

    function aboutLetter(raw) {
      const t = normalize(raw);
      if (t.length < 100) {
        return "Текста недостаточно для уверенного вывода. Добавьте страницу с основной частью письма (где указаны просьбы, сроки или термин).";
      }
      const hasTermin = /termin|einladung|melden sie sich|vorsprechen/.test(t);
      const hasDocs = /unterlagen|nachweis|nachweisen|einreichen|vorlegen|mitwirkung|aufforderung|fehlende|ausfüllen|formular/.test(t);
      const hasPay = /bürgergeld|zahlung|auszahlung|betrag|überweisung|monatlich|leistungen|summe|euro/.test(t);
      const hasBescheid = /bescheid|änderungsbescheid|bewilligung|bewilligungsbescheid|mitteilung|veränderungsmitteilung/.test(t);

      if (hasTermin) return "В письме обнаружены слова, связанные с термином/встречей. Обычно это означает необходимость прийти или ответить.";
      if (hasDocs) return "В письме обнаружены слова, связанные с документами/подтверждениями. Обычно это означает необходимость предоставить документы.";
      if (hasPay) return "В письме обнаружены слова, связанные с выплатами/суммами. Часто это информирование о расчётах.";
      if (hasBescheid) return "В письме обнаружены слова, связанные с решением/уведомлением (Bescheid). Проверьте, есть ли сроки или просьбы.";
      return "Письмо содержит общий текст. Для точности важны страницы со сроками/просьбами (Bitte / Frist / Termin).";
    }

    function showResult(res, combinedText) {
      doneBanner.style.display = "block";

      // доп. предупреждение, если warn есть
      const warn = warnIndexes();
      const warnLine = warn.length ? ("⚠️ Частично распознаны страницы: " + warn.join(", ") + "\n\n") : "";

      if (res.kind === "needAction") {
        resultTitle.textContent = "✅ Требуется действие";
        resultSupport.textContent = "Это нормально. Ниже — пояснение, что именно требуется.";

        const sig = res.signals.length ? ("Найдены сигналы: " + res.signals.join(", ") + "\n") : "";
        const dl = res.deadline ? ("Срок, указанный в тексте: " + res.deadline + "\n") : "";

        resultDetails.textContent =
          warnLine + sig + dl +
          "Что сделать:\n" +
          "• проверьте, просят ли предоставить документы (Unterlagen / Nachweis),\n" +
          "• или прийти/ответить по термину (Termin / Einladung),\n" +
          "• или заполнить форму (Formular / ausfüllen).\n\n" +
          "Если в письме есть Bitte / Frist / Termin — это прямой сигнал к действию.";
      }
      else if (res.kind === "noAction") {
        resultTitle.textContent = "❌ Действие не требуется";
        resultSupport.textContent =
          "В распознанном тексте не обнаружены просьбы: прислать документы, ответить или прийти в термин.";

        resultDetails.textContent =
          warnLine +
          "Что это значит:\n" +
          "• письмо похоже на информационное уведомление (без обязательных действий).\n" +
          "• если вы ожидаете запрос документов или приглашение — проверьте, не пропущена ли какая-то страница.\n";
      }
      else {
        resultTitle.textContent = "⚠️ Недостаточно данных";
        resultSupport.textContent =
          "Текст распознан частично или отсутствуют ключевые фразы. Добавьте/переснимите страницу с основной частью письма.";

        resultDetails.textContent =
          warnLine +
          "Как исправить:\n" +
          "• снимите страницу ближе (текст должен занимать 70–90% кадра)\n" +
          "• уберите блики/тени\n" +
          "• добавьте страницу со словами Bitte / Frist / Termin (если они есть)\n";
      }

      aboutText.textContent = aboutLetter(combinedText);

      resultBox.style.display = "block";
    }

    // ---------------- Events ----------------
    cameraBtn.addEventListener("click", () => {
      if (isLocked) return;
      cameraInput.click();
    });

    filesBtn.addEventListener("click", () => {
      if (isLocked) return;
      filesInput.click();
    });

    cameraInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(cameraInput.files);
    });

    filesInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(filesInput.files);
    });

    carousel.addEventListener("scroll", () => updateCounters());

    showBadBtn.addEventListener("click", () => {
      const i = firstBadIndex();
      if (i >= 0) scrollToPage(i);
    });

    showWarnBtn.addEventListener("click", () => {
      const i = firstWarnIndex();
      if (i >= 0) scrollToPage(i);
    });

    deleteBadBtn.addEventListener("click", () => {
      if (isLocked) return;
      const toRemove = pages.filter(p => p.bad).map(p => p.id);
      toRemove.forEach(id => removePage(id));
      updateQualityPanel();
      renderCarousel();
    });

    analyzeBtn.addEventListener("click", async () => {
      if (isLocked) return;
      if (pages.length === 0) { showZeroHintIfNeeded(); return; }

      // BAD => блокируем анализ
      if (hasBadPages()) {
        updateQualityPanel();
        return;
      }

      // старт анализа
      setLocked(true);
      resultBox.style.display = "none";
      doneBanner.style.display = "none";
      progressBox.style.display = "block";
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Контролируем содержание письма";

      try {
        // OCR по всем страницам (без полного rerender)
        for (let i = 0; i < pages.length; i++) {
          await ocrOnePage(pages[i], i, pages.length);
          updateSlideByIndex(i);
          updateCounters();
          await nextFrame(); // yield (UI не фризит)
        }

        // Обновляем панель качества
        updateQualityPanel();

        // Если появились BAD — стоп (PATCH 2: после unlock обновить панель)
        if (hasBadPages()) {
          progressBox.style.display = "none";
          setLocked(false);

          // PATCH 2: важно обновить disabled-состояние кнопок после unlock
          updateQualityPanel();

          showZeroHintIfNeeded();

          const i = firstBadIndex();
          if (i >= 0) scrollToPage(i);

          await closeOcrWorker();
          return;
        }

        // Продолжаем анализ (rule-based)
        pLine1.textContent = "Анализ идёт";
        pLine2.textContent = "Проверяем, требуется ли от вас действие";
        await nextFrame();

        const combinedText = pages
          .map((p, idx) => `--- Страница ${idx + 1} ---\n${p.ocrText || ""}`)
          .join("\n\n");

        const res = analyzeText(combinedText);

        pLine1.textContent = "Анализ завершён";
        pLine2.textContent = "Ниже — результат проверки письма";

        setTimeout(async () => {
          showResult(res, combinedText);
          progressBox.style.display = "none";
          setLocked(false);
          showZeroHintIfNeeded();
          updateQualityPanel();
          await closeOcrWorker();
        }, 250);

      } catch (e) {
        progressBox.style.display = "none";
        setLocked(false);
        showZeroHintIfNeeded();
        updateQualityPanel();
        await closeOcrWorker();

        resultBox.style.display = "block";
        doneBanner.style.display = "none";

        resultTitle.textContent = "⚠️ Не удалось завершить анализ";
        resultSupport.textContent = "Это нормально. Переснимите страницы ближе и попробуйте ещё раз.";
        resultDetails.textContent =
          "Рекомендации:\n" +
          "• текст должен занимать 70–90% кадра\n" +
          "• без бликов и теней\n" +
          "• переснимите страницы, которые могут быть нечитаемыми\n";
        aboutText.textContent = "—";
      }
    });

    // init
    renderCarousel();
    updateQualityPanel();
    showZeroHintIfNeeded();
  </script>
</body>
</html>
