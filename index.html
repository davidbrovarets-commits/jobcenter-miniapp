<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Jobcenter Letter Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />

  <style>
    .actionsRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .actionsRow .btn{flex:1; min-width:180px;}
    .muted{opacity:0.9}
    .chip{display:inline-block; padding:6px 10px; border-radius:999px; background:rgba(0,0,0,0.12); font-size:12px; opacity:0.95}
    .smallNote{margin-top:8px; font-size:12px; opacity:0.85; line-height:1.35}

    .carouselWrap{margin-top:12px; display:none;}
    .carouselHeader{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px;}
    .carousel{
      display:flex; gap:10px; overflow-x:auto; padding-bottom:8px;
      scroll-snap-type:x mandatory; -webkit-overflow-scrolling:touch;
    }
    .slide{
      scroll-snap-align:start;
      flex:0 0 220px;
      background:rgba(0,0,0,0.10);
      border-radius:14px;
      padding:10px;
      border:2px solid transparent;
      position:relative;
    }
    .slide.bad{border-color:rgba(255,0,0,0.75);}
    .slide img{width:100%; height:150px; object-fit:cover; border-radius:12px; display:block;}
    .slideMeta{margin-top:8px; display:flex; justify-content:space-between; align-items:center; gap:8px;}
    .slideMeta .pageNo{font-weight:700; font-size:13px;}
    .delBtn{
      border:none; background:rgba(0,0,0,0.18); color:inherit;
      border-radius:10px; padding:6px 10px; cursor:pointer; opacity:0.95;
    }
    .delBtn:disabled{opacity:0.4; cursor:not-allowed;}
    .badNote{margin-top:8px; font-size:12px; color:rgba(255,120,120,1); display:none; white-space:pre-wrap;}
    .slide.bad .badNote{display:block;}

    .progressBox{display:none; margin-top:12px; padding:12px; border-radius:14px; background:rgba(0,0,0,0.12);}
    .progressRow{display:flex; align-items:center; gap:12px;}
    .ring{
      width:26px; height:26px; border-radius:50%;
      border:3px solid rgba(255,255,255,0.22);
      border-top-color: rgba(255,255,255,0.85);
      animation: spin 0.9s linear infinite;
      flex:0 0 auto;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .progressText{line-height:1.25}
    .progressText .t1{font-weight:800}
    .progressText .t2{opacity:0.95; margin-top:2px}
    .lockNote{margin-top:8px; font-size:12px; opacity:0.9}

    .hintBox{margin-top:10px; padding:10px 12px; border-radius:14px; background:rgba(0,0,0,0.10); display:none;}

    .panel{display:none; margin-top:12px; padding:12px; border-radius:14px; background:rgba(0,0,0,0.12);}
    .panelTitle{font-weight:800; margin-bottom:6px;}
    .panelText{white-space:pre-wrap; opacity:0.95;}
    .panelActions{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .panelActions .btn{flex:1; min-width:220px;}
  </style>
</head>

<body>
  <div class="app">
    <h1 id="title">Проверка письма Jobcenter</h1>
    <p id="subtitle">Помогаем понять, требуется ли действие по письму.</p>

    <div class="card">
      <p id="disclaimer">
        Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.
      </p>

      <div class="actionsRow">
        <button id="cameraBtn" class="btn" type="button">Сделать фото</button>
        <button id="filesBtn"  class="btn" type="button">Выбрать файлы</button>
      </div>

      <div class="smallNote">
        <b>Важно:</b> PDF в Telegram Mini App часто не обрабатывается. Для надёжного результата используйте фото/скрин страниц письма.
      </div>

      <input id="cameraInput" type="file" accept="image/*" capture="environment" style="display:none" />
      <input id="filesInput"  type="file" accept="image/*" multiple style="display:none" />

      <!-- Карусель -->
      <div id="carouselWrap" class="carouselWrap">
        <div class="carouselHeader">
          <div class="chip" id="pagesCount">Добавлено: 0</div>
          <div class="chip" id="pageIndex">Страница: 0 / 0</div>
        </div>
        <div id="carousel" class="carousel"></div>
      </div>

      <!-- Подсказка при 0 страниц -->
      <div id="zeroHint" class="hintBox">
        Для анализа, пожалуйста, добавьте файл.
      </div>

      <!-- Гейт на плохие страницы (A) -->
      <div id="qualityGate" class="panel">
        <div class="panelTitle">Обнаружены нечитаемые страницы</div>
        <div id="qualityText" class="panelText"></div>
        <div class="panelActions">
          <button id="showBadBtn" class="btn" type="button">Показать нечитаемые</button>
          <button id="deleteBadBtn" class="btn" type="button">Удалить нечитаемые</button>
        </div>
        <div class="smallNote">
          Переснимите/замените отмеченные страницы и повторите анализ. Это нужно, чтобы результат был точным и полным.
        </div>
      </div>

      <!-- Кнопка финального запуска -->
      <button id="analyzeBtn" class="btn" type="button" style="margin-top:12px; width:100%;" disabled>
        Готово → Анализ
      </button>

      <!-- Прогресс -->
      <div id="progressBox" class="progressBox">
        <div class="progressRow">
          <div class="ring" aria-hidden="true"></div>
          <div class="progressText">
            <div id="pLine1" class="t1">Анализ идёт</div>
            <div id="pLine2" class="t2">Контролируем содержание письма</div>
          </div>
        </div>
        <div id="lockNote" class="lockNote">
          Во время анализа добавление и удаление страниц временно недоступны.
        </div>
      </div>

      <!-- Результат -->
      <div id="resultBox" class="panel">
        <div id="doneBanner" style="display:none; margin-bottom:10px;">
          <div style="font-weight:800;">Анализ завершён</div>
          <div style="opacity:0.95; margin-top:2px;">Ниже — результат проверки письма</div>
        </div>

        <div id="resultTitle" class="panelTitle"></div>
        <div id="resultSupport" class="panelText" style="margin-bottom:10px;"></div>
        <div id="resultDetails" class="panelText"></div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.14);">
          <div class="panelTitle">Кратко о письме</div>
          <div id="aboutText" class="panelText"></div>
        </div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.14);">
          <div class="panelTitle">Перевод (следующий этап)</div>
          <div class="panelText">
Независимо от результата мы добавим понятный перевод и объяснение письма.
Это будет подключено на следующем этапе через AI (после стабилизации входа и многостраничности).
          </div>
        </div>
      </div>

      <small class="version" style="display:block; margin-top:12px; opacity:0.85;">
        v1.3 · Quality gate (A) + confident wording + stable multi-page images
      </small>
    </div>
  </div>

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // Telegram init (safe)
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg) { tg.ready(); tg.expand(); }

    // DOM
    const cameraBtn = document.getElementById("cameraBtn");
    const filesBtn  = document.getElementById("filesBtn");
    const cameraInput = document.getElementById("cameraInput");
    const filesInput  = document.getElementById("filesInput");

    const carouselWrap = document.getElementById("carouselWrap");
    const carousel = document.getElementById("carousel");
    const pagesCount = document.getElementById("pagesCount");
    const pageIndex = document.getElementById("pageIndex");

    const analyzeBtn = document.getElementById("analyzeBtn");
    const zeroHint = document.getElementById("zeroHint");

    const progressBox = document.getElementById("progressBox");
    const pLine1 = document.getElementById("pLine1");
    const pLine2 = document.getElementById("pLine2");

    const qualityGate = document.getElementById("qualityGate");
    const qualityText = document.getElementById("qualityText");
    const showBadBtn = document.getElementById("showBadBtn");
    const deleteBadBtn = document.getElementById("deleteBadBtn");

    const resultBox = document.getElementById("resultBox");
    const doneBanner = document.getElementById("doneBanner");
    const resultTitle = document.getElementById("resultTitle");
    const resultSupport = document.getElementById("resultSupport");
    const resultDetails = document.getElementById("resultDetails");
    const aboutText = document.getElementById("aboutText");

    // State
    const pages = []; // {id, file, thumbUrl, fullUrl, bad:false, badReason:"", ocrText:"", ocrConfidence:null}
    let isLocked = false;

    // ---------- Helpers ----------
    function uid() {
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    function hasBadPages() {
      return pages.some(p => p.bad);
    }

    function setLocked(v) {
      isLocked = v;
      cameraBtn.disabled = v;
      filesBtn.disabled = v;

      // анализ можно запускать только если: не залочено, есть страницы, нет bad pages
      analyzeBtn.disabled = v || pages.length === 0 || hasBadPages();

      // блокируем кнопки удаления
      carousel.querySelectorAll("button[data-del]").forEach(btn => btn.disabled = v);
    }

    function showZeroHintIfNeeded() {
      if (pages.length === 0) {
        zeroHint.style.display = "block";
      } else {
        zeroHint.style.display = "none";
      }
      analyzeBtn.disabled = isLocked || pages.length === 0 || hasBadPages();
    }

    function updateCounters() {
      pagesCount.textContent = "Добавлено: " + pages.length;
      if (pages.length === 0) {
        pageIndex.textContent = "Страница: 0 / 0";
      } else {
        const idx = getVisibleIndex();
        pageIndex.textContent = "Страница: " + (idx + 1) + " / " + pages.length;
      }
    }

    function getVisibleIndex() {
      if (!pages.length) return 0;
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      if (!slides.length) return 0;
      const left = carousel.scrollLeft;
      let best = 0;
      let bestDist = Infinity;
      slides.forEach((s, i) => {
        const dist = Math.abs(s.offsetLeft - left);
        if (dist < bestDist) { bestDist = dist; best = i; }
      });
      return best;
    }

    function scrollToPage(index) {
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      const s = slides[index];
      if (!s) return;
      carousel.scrollTo({ left: s.offsetLeft, behavior: "smooth" });
    }

    function renderCarousel() {
      carousel.innerHTML = "";

      if (pages.length === 0) {
        carouselWrap.style.display = "none";
        updateCounters();
        showZeroHintIfNeeded();
        return;
      }

      carouselWrap.style.display = "block";

      pages.forEach((p, idx) => {
        const slide = document.createElement("div");
        slide.className = "slide" + (p.bad ? " bad" : "");
        slide.dataset.id = p.id;

        const img = document.createElement("img");
        img.src = p.thumbUrl;
        img.alt = "Страница " + (idx + 1);

        const meta = document.createElement("div");
        meta.className = "slideMeta";

        const pageNo = document.createElement("div");
        pageNo.className = "pageNo";
        pageNo.textContent = "Стр. " + (idx + 1);

        const del = document.createElement("button");
        del.className = "delBtn";
        del.type = "button";
        del.textContent = "Удалить";
        del.dataset.del = p.id;
        del.disabled = isLocked;
        del.addEventListener("click", () => {
          if (isLocked) return;
          removePage(p.id);
        });

        meta.appendChild(pageNo);
        meta.appendChild(del);

        const badNote = document.createElement("div");
        badNote.className = "badNote";
        badNote.textContent = p.badReason || "Страница плохо читается. Переснимите/замените для точного результата.";

        slide.appendChild(img);
        slide.appendChild(meta);
        slide.appendChild(badNote);

        carousel.appendChild(slide);
      });

      updateCounters();
      showZeroHintIfNeeded();
    }

    function removePage(id) {
      const i = pages.findIndex(p => p.id === id);
      if (i >= 0) {
        try { URL.revokeObjectURL(pages[i].thumbUrl); } catch(e) {}
        try { URL.revokeObjectURL(pages[i].fullUrl); } catch(e) {}
        pages.splice(i, 1);
      }
      // при удалении обновляем гейт и кнопки
      updateQualityGate();
      renderCarousel();
      resultBox.style.display = "none";
      progressBox.style.display = "none";
    }

    async function createThumbAndFull(file) {
      const fullUrl = URL.createObjectURL(file);
      const thumbUrl = fullUrl;
      return { thumbUrl, fullUrl };
    }

    async function addFiles(fileList) {
      const arr = Array.from(fileList || []);
      if (!arr.length) return;

      // при добавлении новых файлов: сбрасываем старые bad-оценки только для новых страниц
      for (const f of arr) {
        if (!f || !f.type || !f.type.startsWith("image/")) continue;
        const { thumbUrl, fullUrl } = await createThumbAndFull(f);
        pages.push({
          id: uid(),
          file: f,
          thumbUrl,
          fullUrl,
          bad: false,
          badReason: "",
          ocrText: "",
          ocrConfidence: null
        });
      }

      cameraInput.value = "";
      filesInput.value = "";

      // Скрываем панели при новом добавлении
      resultBox.style.display = "none";
      qualityGate.style.display = "none";
      progressBox.style.display = "none";

      renderCarousel();
      updateQualityGate();
    }

    // OCR helpers
    async function downscaleToDataUrl(file, maxSide = 1800) {
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.src = url;

      await new Promise((res, rej) => {
        img.onload = () => res();
        img.onerror = () => rej(new Error("Image load failed"));
      });

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      const scale = Math.min(1, maxSide / Math.max(w, h));
      const nw = Math.max(1, Math.round(w * scale));
      const nh = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement("canvas");
      canvas.width = nw;
      canvas.height = nh;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, nw, nh);

      URL.revokeObjectURL(url);
      return canvas.toDataURL("image/jpeg", 0.9);
    }

    function cleanOcrText(t) {
      let s = (t || "");
      s = s.replace(/[^\S\r\n]+/g, " ");
      s = s.replace(/\n{3,}/g, "\n\n");
      s = s.replace(/[|}{]{2,}/g, " ");
      s = s.replace(/[^\p{L}\p{N}\s.,:;!?()+\-\/€$@%]/gu, "");
      s = s.replace(/\s{2,}/g, " ").trim();
      return s;
    }

    async function ocrOnePage(pageObj, idx, total) {
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Обрабатываем страницы: " + (idx + 1) + " из " + total;

      const dataUrl = await downscaleToDataUrl(pageObj.file, 1800);
      const { data } = await Tesseract.recognize(dataUrl, "deu+rus", {});

      const rawText = (data && data.text) ? data.text : "";
      const cleaned = cleanOcrText(rawText);
      const confidence = (data && typeof data.confidence === "number") ? data.confidence : null;

      pageObj.ocrText = cleaned;
      pageObj.ocrConfidence = confidence;

      const tooShort = cleaned.length < 60;
      const lowConf = (confidence !== null && confidence < 55);

      if (tooShort || lowConf) {
        pageObj.bad = true;
        let reason = "Качество распознавания низкое. Рекомендуем переснять/заменить для точного результата.";
        if (tooShort && lowConf) reason = "Страница распознана плохо (мало текста и низкое качество). Рекомендуем переснять/заменить.";
        else if (tooShort) reason = "На странице почти не удалось распознать текст. Рекомендуем переснять/заменить.";
        pageObj.badReason = reason;
      } else {
        pageObj.bad = false;
        pageObj.badReason = "";
      }
    }

    // ---------- Analysis (rule-based, без "возможно/похоже") ----------
    function normalize(s) {
      return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
    }

    function findDeadline(text) {
      const m1 = text.match(/\b(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m1) return m1[1];
      const m2 = text.match(/\b(bis zum|spätestens am|frist|fristen|bis spätestens)\s+(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m2) return m2[2];
      return "";
    }

    function analyzeText(raw) {
      const t = normalize(raw);
      if (t.length < 100) return { kind: "insufficient", deadline: "", signals: [] };

      const signalsAction = [
        "bitte","wir bitten","sie werden gebeten","sie sind verpflichtet",
        "erforderlich","nachweisen","nachweis","einreichen","vorlegen",
        "termin","einladung","melden sie sich","rückmeldung",
        "frist","bis zum","spätestens","umgehend",
        "anhörung","mitwirkung","aufforderung","fehlende unterlagen",
        "unterlagen","kontoauszüge","mietvertrag","ausfüllen","formular"
      ];

      const found = signalsAction.filter(w => t.includes(w));
      const deadline = findDeadline(t);

      // Решение через факты: "найдены сигналы" vs "не найдены"
      if (found.length >= 2 || (found.length >= 1 && (t.includes("frist") || t.includes("termin") || deadline))) {
        return { kind: "needAction", deadline, signals: found.slice(0, 6) };
      }

      // если явных сигналов действия нет — считаем "не требуется действие"
      return { kind: "noAction", deadline: "", signals: [] };
    }

    function aboutLetter(raw) {
      const t = normalize(raw);
      if (t.length < 100) {
        return "Текста недостаточно для уверенного вывода. Добавьте страницу с основной частью письма (где указаны просьбы, сроки или термин).";
      }
      const hasTermin = /termin|einladung|melden sie sich|vorsprechen/.test(t);
      const hasDocs = /unterlagen|nachweis|nachweisen|einreichen|vorlegen|mitwirkung|aufforderung|fehlende|ausfüllen|formular/.test(t);
      const hasPay = /bürgergeld|zahlung|auszahlung|betrag|überweisung|monatlich/.test(t);
      const hasBescheid = /bescheid|änderungsbescheid|bewilligung|bewilligungsbescheid|mitteilung|veränderungsmitteilung/.test(t);

      if (hasTermin) return "В письме обнаружены слова, связанные с термином/встречей. Обычно это означает необходимость прийти или ответить.";
      if (hasDocs) return "В письме обнаружены слова, связанные с документами/подтверждениями. Обычно это означает необходимость предоставить документы.";
      if (hasPay) return "В письме обнаружены слова, связанные с выплатами/суммами. Часто это информирование о расчётах.";
      if (hasBescheid) return "В письме обнаружены слова, связанные с решением/уведомлением (Bescheid). Проверьте, есть ли сроки или просьбы.";
      return "Письмо содержит общий текст. Для точности важны страницы со сроками/просьбами (Bitte / Frist / Termin).";
    }

    function showResult(res, combinedText) {
      doneBanner.style.display = "block";

      if (res.kind === "needAction") {
        resultTitle.textContent = "✅ Требуется действие";
        resultSupport.textContent = "Это нормально. Ниже — пояснение, что именно требуется.";

        const sig = res.signals.length ? ("Найдены сигналы: " + res.signals.join(", ") + "\n") : "";
        const dl = res.deadline ? ("Срок, указанный в тексте: " + res.deadline + "\n") : "";

        resultDetails.textContent =
          sig + dl +
          "Что сделать:\n" +
          "• проверьте, просят ли предоставить документы (Unterlagen / Nachweis),\n" +
          "• или прийти/ответить по термину (Termin / Einladung),\n" +
          "• или заполнить форму (Formular / ausfüllen).\n\n" +
          "Совет: если в письме есть Bitte / Frist / Termin — это прямой сигнал к действию.";
      }
      else if (res.kind === "noAction") {
        resultTitle.textContent = "❌ Действие не требуется";
        resultSupport.textContent =
          "В распознанном тексте не обнаружены просьбы: прислать документы, ответить или прийти в термин.";

        resultDetails.textContent =
          "Что это значит:\n" +
          "• письмо похоже на информационное уведомление (без обязательных действий).\n" +
          "• если вы ожидаете запрос документов или приглашение — проверьте, не пропущена ли какая-то страница.\n";
      }
      else {
        resultTitle.textContent = "⚠️ Недостаточно данных";
        resultSupport.textContent =
          "Текст распознан частично или отсутствуют ключевые фразы. Добавьте/переснимите страницу с основной частью письма.";

        resultDetails.textContent =
          "Как исправить:\n" +
          "• снимите страницу ближе (текст должен занимать 70–90% кадра)\n" +
          "• уберите блики/тени\n" +
          "• добавьте страницу со словами Bitte / Frist / Termin (если они есть)\n";
      }

      aboutText.textContent = aboutLetter(combinedText);

      resultBox.style.display = "block";
      qualityGate.style.display = "none";
    }

    // ---------- Quality Gate (A) ----------
    function updateQualityGate() {
      if (!hasBadPages()) {
        qualityGate.style.display = "none";
        qualityText.textContent = "";
        analyzeBtn.disabled = isLocked || pages.length === 0;
        return;
      }

      const badIdx = pages
        .map((p, i) => p.bad ? (i + 1) : null)
        .filter(Boolean);

      qualityGate.style.display = "block";
      qualityText.textContent =
        "Нечитаемые страницы: " + badIdx.join(", ") + "\n" +
        "Чтобы анализ был точным, исправьте их: переснимите или удалите.";

      // пока есть bad — анализ запрещён
      analyzeBtn.disabled = true;
    }

    showBadBtn.addEventListener("click", () => {
      const firstBad = pages.findIndex(p => p.bad);
      if (firstBad >= 0) scrollToPage(firstBad);
    });

    deleteBadBtn.addEventListener("click", () => {
      if (isLocked) return;
      const toRemove = pages.filter(p => p.bad).map(p => p.id);
      toRemove.forEach(id => removePage(id));
      updateQualityGate();
      renderCarousel();
    });

    // ---------- Events ----------
    cameraBtn.addEventListener("click", () => {
      if (isLocked) return;
      cameraInput.click();
    });

    filesBtn.addEventListener("click", () => {
      if (isLocked) return;
      filesInput.click();
    });

    cameraInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(cameraInput.files);
    });

    filesInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(filesInput.files);
    });

    carousel.addEventListener("scroll", () => updateCounters());

    analyzeBtn.addEventListener("click", async () => {
      if (isLocked) return;
      if (pages.length === 0) { showZeroHintIfNeeded(); return; }
      if (hasBadPages()) { updateQualityGate(); return; } // A: блокируем

      // Старт анализа
      setLocked(true);
      resultBox.style.display = "none";
      qualityGate.style.display = "none";
      doneBanner.style.display = "none";

      progressBox.style.display = "block";
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Контролируем содержание письма";

      try {
        // OCR по всем страницам
        for (let i = 0; i < pages.length; i++) {
          await ocrOnePage(pages[i], i, pages.length);
          renderCarousel();
        }

        // После OCR: если выявились bad pages — включаем гейт (A) и стоп
        updateQualityGate();
        if (hasBadPages()) {
          progressBox.style.display = "none";
          setLocked(false);
          showZeroHintIfNeeded();
          // автопрокрутка к первой проблемной
          const firstBad = pages.findIndex(p => p.bad);
          if (firstBad >= 0) scrollToPage(firstBad);
          return;
        }

        // Перед результатом
        pLine1.textContent = "Анализ идёт";
        pLine2.textContent = "Проверяем, требуется ли от вас действие";

        const combinedText = pages
          .map((p, idx) => `--- Страница ${idx + 1} ---\n${p.ocrText || ""}`)
          .join("\n\n");

        const res = analyzeText(combinedText);

        // Завершение
        pLine1.textContent = "Анализ завершён";
        pLine2.textContent = "Ниже — результат проверки письма";

        setTimeout(() => {
          showResult(res, combinedText);
          progressBox.style.display = "none";
          setLocked(false);
          showZeroHintIfNeeded();
        }, 350);

      } catch (e) {
        progressBox.style.display = "none";
        setLocked(false);
        showZeroHintIfNeeded();

        resultBox.style.display = "block";
        qualityGate.style.display = "none";
        doneBanner.style.display = "none";

        resultTitle.textContent = "⚠️ Не удалось завершить анализ";
        resultSupport.textContent = "Это нормально. Переснимите страницы ближе и попробуйте ещё раз.";
        resultDetails.textContent =
          "Рекомендации:\n" +
          "• текст должен занимать 70–90% кадра\n" +
          "• без бликов и теней\n" +
          "• переснимите страницы, которые могут быть нечитаемыми\n";
        aboutText.textContent = "—";
      }
    });

    // init
    renderCarousel();
    updateQualityGate();
    showZeroHintIfNeeded();
  </script>
</body>
</html>
