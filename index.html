<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Jobcenter Letter Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="app">
    <h1 id="title">Проверка письма Jobcenter</h1>
    <p id="subtitle">Помогаем понять, требуется ли действие по письму.</p>

    <div class="card">
      <h3 id="chooseLang">Выберите язык</h3>

      <div class="lang-buttons">
        <button id="btnRu" type="button">RU Русский</button>
        <button id="btnUa" type="button">UA Українська</button>
      </div>

      <p id="disclaimer">
        Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.
      </p>

      <!-- Upload -->
      <button id="uploadBtn" class="btn" type="button">Загрузить письмо</button>
      <input id="fileInput" type="file" accept="application/pdf,image/*" style="display:none" />

      <div id="fileInfo" style="margin-top:10px; opacity:0.95;"></div>

      <!-- Image preview -->
      <img id="imagePreview" alt="" style="display:none; margin-top:10px; width:100%; border-radius:12px;" />

      <!-- OCR tips -->
      <div id="tipsBox" style="display:none; margin-top:10px; padding:10px 12px; border-radius:12px; background:rgba(0,0,0,0.12);">
        <div id="tipsTitle" style="font-weight:700; margin-bottom:6px;">Советы для хорошего OCR</div>
        <div id="tipsText" style="white-space:pre-wrap; opacity:0.95;"></div>
      </div>

      <!-- OCR controls -->
      <button id="ocrBtn" class="btn" type="button" style="margin-top:10px; width:100%; display:none;">
        Распознать текст (OCR)
      </button>
      <div id="ocrStatus" style="margin-top:8px; opacity:0.9; display:none;"></div>

      <!-- Text input -->
      <div style="margin-top:14px;">
        <label id="pasteLabel" for="textInput" style="display:block; margin-bottom:8px; opacity:0.95;">
          Вставьте текст письма (если OCR ещё не подключен)
        </label>
        <textarea
          id="textInput"
          rows="7"
          placeholder="Вставьте сюда текст письма Jobcenter…"
          style="width:100%; padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.15); background:rgba(0,0,0,0.12); color:inherit; resize:vertical;"
        ></textarea>

        <button id="analyzeBtn" class="btn" type="button" style="margin-top:10px; width:100%;">
          Анализировать
        </button>
      </div>

      <!-- Result -->
      <div id="resultBox" style="display:none; margin-top:12px; padding:12px; border-radius:12px; background:rgba(0,0,0,0.12);">
        <div id="resultTitle" style="font-weight:700; margin-bottom:6px;"></div>
        <div id="resultDetails" style="white-space:pre-wrap; opacity:0.95;"></div>
      </div>

      <p class="hint" id="hint" style="margin-top:12px;">
        Шаг: загрузите фото письма → проверьте советы → нажмите OCR → затем Анализировать.
      </p>
    </div>

    <small class="version">v0.8 · OCR UX checks + tips + clean text</small>
  </div>

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // Telegram init (safe)
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg) { tg.ready(); tg.expand(); }

    const TEXTS = {
      ru: {
        title: "Проверка письма Jobcenter",
        subtitle: "Помогаем понять, требуется ли действие по письму.",
        chooseLang: "Выберите язык",
        disclaimer: "Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.",
        upload: "Загрузить письмо",
        pasteLabel: "Вставьте текст письма (если OCR ещё не подключен)",
        pastePlaceholder: "Вставьте сюда текст письма Jobcenter…",
        analyze: "Анализировать",
        hint: "Шаг: загрузите фото письма → проверьте советы → нажмите OCR → затем Анализировать.",
        ocrBtn: "Распознать текст (OCR)",
        ocrNoImage: "Сначала выберите изображение (фото).",
        ocrWorking: (p) => `OCR работает… ${p}%`,
        ocrDone: "OCR готово. Текст очищен и вставлен в поле ниже.",
        ocrFail: "OCR не получилось. Попробуйте фото чётче/ближе и без бликов.",
        fileInfo: (name, kb, type) => `Файл: ${name} (${kb} KB) · Тип: ${type}`,
        pickedPdf: "✅ PDF выбран. OCR для PDF добавим следующим шагом. Пока можно вставить текст вручную.",
        pickedImage: "✅ Изображение выбрано. Можно нажать OCR.",
        unknownType: "⚠️ Неизвестный тип файла. Попробуйте PDF или изображение.",
        tipsTitle: "Советы для хорошего OCR",
        tipsText:
          "• Держите камеру ровно сверху (без наклона)\n" +
          "• Поднесите ближе: текст должен занимать 70–90% кадра\n" +
          "• Уберите блики и тени (не фотографируйте напротив лампы)\n" +
          "• Лучше яркий свет, чем тёмный кадр\n" +
          "• Если фото размыто — сделайте ещё раз",
        qualityGood: "✅ Качество фото выглядит нормально для OCR.",
        qualityBad: (msg) => `⚠️ Фото может распознаться плохо: ${msg}`,
        res_needAction: "✅ Требуется действие",
        res_noAction: "❌ Действие не требуется (скорее всего)",
        res_unclear: "⚠️ Неясно — нужна проверка",
        res_empty: "Введите или вставьте текст письма — хотя бы 2–3 строки.",
        details_needAction: (deadline) =>
          `Похоже, Jobcenter ожидает от вас действие.\n` +
          (deadline ? `Обнаружен возможный срок: ${deadline}\n` : "") +
          `Следующий шаг: проверьте, что именно требуют (документы/ответ/явка) и подготовьте действие.`,
        details_noAction:
          `Похоже, это уведомление/информация.\n` +
          `Если в тексте нет просьбы прислать документы, прийти в термин или ответить — часто действие не требуется.\n` +
          `Если сомневаетесь — лучше перепроверить.`,
        details_unclear:
          `Сигналы неочевидны.\n` +
          `Для точности нужны 1–2 абзаца со сроком/термином (Bitte/Frist/Termin).`
      },
      ua: {
        title: "Перевірка листа Jobcenter",
        subtitle: "Допомагаємо зрозуміти, чи потрібна дія за листом.",
        chooseLang: "Оберіть мову",
        disclaimer: "Це не юридична консультація. Сервіс показує лише: чи потрібна дія за листом.",
        upload: "Завантажити лист",
        pasteLabel: "Вставте текст листа (якщо OCR ще не підключено)",
        pastePlaceholder: "Вставте сюди текст листа Jobcenter…",
        analyze: "Аналізувати",
        hint: "Крок: завантажте фото → перегляньте поради → натисніть OCR → потім Аналізувати.",
        ocrBtn: "Розпізнати текст (OCR)",
        ocrNoImage: "Спочатку виберіть зображення (фото).",
        ocrWorking: (p) => `OCR працює… ${p}%`,
        ocrDone: "OCR готово. Текст очищено і вставлено нижче.",
        ocrFail: "OCR не вдалося. Спробуйте чіткіше фото без відблисків.",
        fileInfo: (name, kb, type) => `Файл: ${name} (${kb} KB) · Тип: ${type}`,
        pickedPdf: "✅ PDF обрано. OCR для PDF додамо наступним кроком. Поки можна вставити текст вручну.",
        pickedImage: "✅ Зображення обрано. Можна натиснути OCR.",
        unknownType: "⚠️ Невідомий тип файлу. Спробуйте PDF або зображення.",
        tipsTitle: "Поради для гарного OCR",
        tipsText:
          "• Тримайте камеру рівно зверху (без нахилу)\n" +
          "• Підійдіть ближче: текст має займати 70–90% кадру\n" +
          "• Приберіть відблиски і тіні\n" +
          "• Краще яскраве світло, ніж темний кадр\n" +
          "• Якщо розмито — зробіть фото ще раз",
        qualityGood: "✅ Якість фото виглядає нормально для OCR.",
        qualityBad: (msg) => `⚠️ Фото може розпізнатися погано: ${msg}`,
        res_needAction: "✅ Потрібна дія",
        res_noAction: "❌ Дія не потрібна (ймовірно)",
        res_unclear: "⚠️ Незрозуміло — потрібна перевірка",
        res_empty: "Вставте текст — хоча б 2–3 рядки.",
        details_needAction: (deadline) =>
          `Схоже, Jobcenter очікує від вас дію.\n` +
          (deadline ? `Можливий строк: ${deadline}\n` : "") +
          `Далі: перевірте, що саме вимагають, і підготуйте дію.`,
        details_noAction:
          `Схоже, це повідомлення/інформація.\n` +
          `Якщо немає прохання надати документи/прийти/відповісти — часто дія не потрібна.\n` +
          `Якщо сумніваєтесь — переперевірте.`,
        details_unclear:
          `Сигнали неочевидні.\n` +
          `Для точності потрібні 1–2 абзаци зі строком/терміном (Bitte/Frist/Termin).`
      }
    };

    let currentLang = "ru";
    function setLang(lang) {
      currentLang = lang;
      document.documentElement.lang = lang;
      title.textContent = TEXTS[lang].title;
      subtitle.textContent = TEXTS[lang].subtitle;
      chooseLang.textContent = TEXTS[lang].chooseLang;
      disclaimer.textContent = TEXTS[lang].disclaimer;
      uploadBtn.textContent = TEXTS[lang].upload;
      pasteLabel.textContent = TEXTS[lang].pasteLabel;
      textInput.placeholder = TEXTS[lang].pastePlaceholder;
      analyzeBtn.textContent = TEXTS[lang].analyze;
      hint.textContent = TEXTS[lang].hint;
      ocrBtn.textContent = TEXTS[lang].ocrBtn;
      tipsTitle.textContent = TEXTS[lang].tipsTitle;
      tipsText.textContent = TEXTS[lang].tipsText;
    }

    // --- Analyzer ---
    function normalize(s) {
      return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
    }
    function findDeadline(text) {
      const m1 = text.match(/\b(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m1) return m1[1];
      const m2 = text.match(/\b(bis zum|spätestens am|frist|fristen|bis spätestens)\s+(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m2) return m2[2];
      return "";
    }
    function analyzeText(raw) {
      const t = normalize(raw);
      if (t.length < 30) return { kind: "empty" };

      const actionSignals = [
        "bitte","wir bitten","sie werden gebeten","sie sind verpflichtet",
        "erforderlich","nachweisen","nachweis","einreichen","vorlegen",
        "termin","einladung","melden sie sich","rückmeldung",
        "frist","bis zum","spätestens","umgehend","sofort",
        "anhörung","mitwirkung","aufforderung","fehlende unterlagen",
        "unterlagen","kontoauszüge","mietvertrag"
      ];
      const infoSignals = [
        "bewilligung","bescheid","mitteilung","information",
        "zahlung","auszahlung","überweisung","betrag",
        "wir informieren","zur kenntnis","hinweis","änderungsbescheid"
      ];

      let actionScore = 0, infoScore = 0;
      for (const w of actionSignals) if (t.includes(w)) actionScore++;
      for (const w of infoSignals) if (t.includes(w)) infoScore++;

      const deadline = findDeadline(t);

      if (actionScore >= 2 || (actionScore >= 1 && (t.includes("frist") || t.includes("termin") || deadline))) {
        return { kind: "needAction", deadline };
      }
      if (infoScore >= 2 && actionScore === 0) return { kind: "noAction" };
      return { kind: "unclear" };
    }
    function showResult(kind, deadline) {
      resultBox.style.display = "block";
      if (kind === "empty") {
        resultTitle.textContent = TEXTS[currentLang].res_unclear;
        resultDetails.textContent = TEXTS[currentLang].res_empty;
        return;
      }
      if (kind === "needAction") {
        resultTitle.textContent = TEXTS[currentLang].res_needAction;
        resultDetails.textContent = TEXTS[currentLang].details_needAction(deadline || "");
        return;
      }
      if (kind === "noAction") {
        resultTitle.textContent = TEXTS[currentLang].res_noAction;
        resultDetails.textContent = TEXTS[currentLang].details_noAction;
        return;
      }
      resultTitle.textContent = TEXTS[currentLang].res_unclear;
      resultDetails.textContent = TEXTS[currentLang].details_unclear;
    }

    // --- OCR helpers: downscale + simple quality check ---
    async function downscaleImageToDataUrl(file, maxSide = 1600) {
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.src = url;
      await new Promise((res, rej) => {
        img.onload = () => res();
        img.onerror = () => rej(new Error("Image load failed"));
      });

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      const scale = Math.min(1, maxSide / Math.max(w, h));
      const nw = Math.round(w * scale);
      const nh = Math.round(h * scale);

      const canvas = document.createElement("canvas");
      canvas.width = nw;
      canvas.height = nh;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, nw, nh);

      URL.revokeObjectURL(url);
      return { dataUrl: canvas.toDataURL("image/jpeg", 0.9), canvas };
    }

    function qualityCheck(canvas) {
      // Very simple heuristic:
      // - too dark -> low avg brightness
      // - too low contrast -> low std
      // - too small -> dimensions
      const w = canvas.width, h = canvas.height;
      if (w < 700 || h < 700) return { ok: false, msg: "слишком маленькое изображение. Сделайте фото ближе." };

      const ctx = canvas.getContext("2d");
      const img = ctx.getImageData(0, 0, w, h);
      const d = img.data;

      // sample pixels (every ~20th pixel) for speed
      const step = 80; // larger = faster
      let n = 0;
      let sum = 0;
      let sumSq = 0;

      for (let i = 0; i < d.length; i += 4 * step) {
        const r = d[i], g = d[i+1], b = d[i+2];
        // luminance
        const y = 0.2126*r + 0.7152*g + 0.0722*b;
        sum += y;
        sumSq += y*y;
        n++;
      }

      const mean = sum / n;
      const varr = (sumSq / n) - (mean * mean);
      const std = Math.sqrt(Math.max(0, varr));

      if (mean < 85) return { ok: false, msg: "кадр слишком тёмный. Добавьте света." };
      if (std < 28) return { ok: false, msg: "низкий контраст/размытие. Уберите блики и держите камеру ровно." };

      return { ok: true, msg: "" };
    }

    function cleanOcrText(t) {
      let s = (t || "");
      // remove weird repeating chars and normalize spacing
      s = s.replace(/[^\S\r\n]+/g, " ");      // collapse spaces
      s = s.replace(/\n{3,}/g, "\n\n");       // collapse newlines
      s = s.replace(/[|}{]{2,}/g, " ");       // noisy symbols
      s = s.replace(/[^\p{L}\p{N}\s.,:;!?()+\-\/€$@%]/gu, ""); // keep letters/numbers/punct
      s = s.replace(/\s{2,}/g, " ").trim();
      return s;
    }

    // DOM
    const title = document.getElementById("title");
    const subtitle = document.getElementById("subtitle");
    const chooseLang = document.getElementById("chooseLang");
    const disclaimer = document.getElementById("disclaimer");

    const btnRu = document.getElementById("btnRu");
    const btnUa = document.getElementById("btnUa");
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    const fileInfo = document.getElementById("fileInfo");
    const imagePreview = document.getElementById("imagePreview");

    const tipsBox = document.getElementById("tipsBox");
    const tipsTitle = document.getElementById("tipsTitle");
    const tipsText = document.getElementById("tipsText");

    const ocrBtn = document.getElementById("ocrBtn");
    const ocrStatus = document.getElementById("ocrStatus");

    const pasteLabel = document.getElementById("pasteLabel");
    const textInput = document.getElementById("textInput");
    const analyzeBtn = document.getElementById("analyzeBtn");

    const resultBox = document.getElementById("resultBox");
    const resultTitle = document.getElementById("resultTitle");
    const resultDetails = document.getElementById("resultDetails");
    const hint = document.getElementById("hint");

    let currentFile = null;
    let currentFileKind = null; // 'image' | 'pdf' | null
    let lastDownscaledCanvas = null;

    // Events
    btnRu.addEventListener("click", () => setLang("ru"));
    btnUa.addEventListener("click", () => setLang("ua"));
    uploadBtn.addEventListener("click", () => fileInput.click());

    fileInput.addEventListener("change", async () => {
      // reset
      fileInfo.textContent = "";
      imagePreview.style.display = "none";
      imagePreview.src = "";
      imagePreview.alt = "";

      tipsBox.style.display = "none";

      ocrBtn.style.display = "none";
      ocrStatus.style.display = "none";
      ocrStatus.textContent = "";
      resultBox.style.display = "none";
      lastDownscaledCanvas = null;

      const file = fileInput.files && fileInput.files[0];
      if (!file) return;

      currentFile = file;

      const kb = Math.round(file.size / 1024);
      const mime = (file.type || "").toLowerCase();
      const isPdf = mime === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
      const isImage = mime.startsWith("image/");
      const typeLabel = mime ? mime : "unknown";

      fileInfo.textContent = TEXTS[currentLang].fileInfo(file.name, kb, typeLabel);

      if (isPdf) {
        currentFileKind = "pdf";
        tipsBox.style.display = "none";
        ocrBtn.style.display = "none";
        ocrStatus.style.display = "block";
        ocrStatus.textContent = TEXTS[currentLang].pickedPdf;
        return;
      }

      if (isImage) {
        currentFileKind = "image";

        const url = URL.createObjectURL(file);
        imagePreview.src = url;
        imagePreview.alt = file.name;
        imagePreview.style.display = "block";

        // show tips + quality check (based on downscaled canvas)
        tipsBox.style.display = "block";

        try {
          const { dataUrl, canvas } = await downscaleImageToDataUrl(file, 1600);
          lastDownscaledCanvas = canvas;

          const qc = qualityCheck(canvas);
          ocrStatus.style.display = "block";
          ocrStatus.textContent = qc.ok ? TEXTS[currentLang].qualityGood : TEXTS[currentLang].qualityBad(qc.msg);

          // enable OCR anyway, but user is warned
          ocrBtn.style.display = "block";
        } catch (e) {
          // fallback: still allow OCR
          ocrBtn.style.display = "block";
          ocrStatus.style.display = "block";
          ocrStatus.textContent = TEXTS[currentLang].pickedImage;
        }

        return;
      }

      currentFileKind = null;
      ocrStatus.style.display = "block";
      ocrStatus.textContent = TEXTS[currentLang].unknownType;
    });

    ocrBtn.addEventListener("click", async () => {
      if (!currentFile || currentFileKind !== "image") {
        ocrStatus.style.display = "block";
        ocrStatus.textContent = TEXTS[currentLang].ocrNoImage;
        return;
      }

      try {
        ocrBtn.disabled = true;
        ocrStatus.style.display = "block";
        ocrStatus.textContent = TEXTS[currentLang].ocrWorking(0);

        // use already downscaled canvas if exists; else downscale now
        let dataUrl;
        if (lastDownscaledCanvas) {
          dataUrl = lastDownscaledCanvas.toDataURL("image/jpeg", 0.9);
        } else {
          const r = await downscaleImageToDataUrl(currentFile, 1600);
          dataUrl = r.dataUrl;
        }

        const lang = "deu+rus+ukr";

        const { data } = await Tesseract.recognize(dataUrl, lang, {
          logger: (m) => {
            if (m && m.status === "recognizing text" && typeof m.progress === "number") {
              const pct = Math.round(m.progress * 100);
              ocrStatus.textContent = TEXTS[currentLang].ocrWorking(pct);
            }
          }
        });

        const raw = (data && data.text) ? data.text : "";
        const cleaned = cleanOcrText(raw);

        if (cleaned.length > 0) {
          textInput.value = cleaned;
          ocrStatus.textContent = TEXTS[currentLang].ocrDone;
        } else {
          ocrStatus.textContent = TEXTS[currentLang].ocrFail;
        }
      } catch (e) {
        ocrStatus.textContent = TEXTS[currentLang].ocrFail;
      } finally {
        ocrBtn.disabled = false;
      }
    });

    analyzeBtn.addEventListener("click", () => {
      const raw = textInput.value || "";
      const res = analyzeText(raw);
      showResult(res.kind, res.deadline || "");
    });

    // init
    setLang("ru");
  </script>
</body>
</html>
