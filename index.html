<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Jobcenter Letter Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />

  <style>
    /* Page-local UI styles (component-level) */
    .actionsRow{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .actionsRow .btn{flex:1; min-width:180px;}
    .chip{display:inline-block; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.10); font-size:12px; opacity:0.95}
    .smallNote{margin-top:8px; font-size:12px; opacity:0.88; line-height:1.35}

    .carouselWrap{margin-top:12px; display:none;}
    .carouselHeader{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px;}
    .carousel{
      display:flex; gap:10px; overflow-x:auto; padding-bottom:8px;
      scroll-snap-type:x mandatory; -webkit-overflow-scrolling:touch;
    }
    .slide{
      scroll-snap-align:start;
      flex:0 0 220px;
      background:rgba(255,255,255,0.05);
      border-radius:14px;
      padding:10px;
      border:2px solid transparent;
      position:relative;
    }
    .slide.bad{border-color:rgba(255,0,0,0.75);}
    .slide.warn{border-color:rgba(255,170,0,0.75);}
    .slide img{width:100%; height:150px; object-fit:cover; border-radius:12px; display:block;}
    .slideMeta{margin-top:8px; display:flex; justify-content:space-between; align-items:center; gap:8px;}
    .slideMeta .pageNo{font-weight:800; font-size:13px;}
    .delBtn{
      border:none; background:rgba(255,255,255,0.10); color:inherit;
      border-radius:10px; padding:6px 10px; cursor:pointer; opacity:0.95;
    }
    .delBtn:disabled{opacity:0.4; cursor:not-allowed;}

    .badNote{
      margin-top:8px; font-size:12px; color:rgba(255,120,120,1);
      display:none; white-space:pre-wrap;
    }
    .slide.bad .badNote{display:block;}

    .warnNote{
      margin-top:8px; font-size:12px; color:rgba(255,210,120,1);
      display:none; white-space:pre-wrap;
    }
    .slide.warn .warnNote{display:block;}

    .progressBox{display:none; margin-top:12px; padding:12px; border-radius:14px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.10);}
    .progressRow{display:flex; align-items:center; gap:12px;}
    .ring{
      width:26px; height:26px; border-radius:50%;
      border:3px solid rgba(255,255,255,0.22);
      border-top-color: rgba(255,255,255,0.85);
      animation: spin 0.9s linear infinite;
      flex:0 0 auto;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .progressText{line-height:1.25}
    .progressText .t1{font-weight:900}
    .progressText .t2{opacity:0.95; margin-top:2px}
    .lockNote{margin-top:8px; font-size:12px; opacity:0.9}

    .hintBox{margin-top:10px; padding:10px 12px; border-radius:14px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.10); display:none;}

    .panel{display:none; margin-top:12px; padding:12px; border-radius:14px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.10);}
    .panelTitle{font-weight:900; margin-bottom:6px;}
    .panelText{white-space:pre-wrap; opacity:0.95;}
    .panelActions{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    .panelActions .btn{flex:1; min-width:220px;}
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <span class="badge">MVP · Фото/скрины · RU-only</span>
      <h1 id="title">Проверка письма Jobcenter</h1>
      <p class="subtitle" id="subtitle">Показываем, требуется ли действие по письму.</p>
    </div>

    <div class="card">
      <p class="disclaimer" id="disclaimer">
        Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.
      </p>

      <div class="actionsRow">
        <button id="cameraBtn" class="btn" type="button">Сделать фото</button>
        <button id="filesBtn"  class="btn" type="button">Выбрать файлы</button>
      </div>

      <div class="smallNote">
        <b>Важно:</b> PDF в Telegram Mini App часто не обрабатывается. Для надёжного результата используйте фото/скрин страниц письма.
        <br/>
        <b>Лимит:</b> максимум <span id="maxPagesText"></span> страниц за один анализ.
      </div>

      <input id="cameraInput" type="file" accept="image/*" capture="environment" style="display:none" />
      <input id="filesInput"  type="file" accept="image/*" multiple style="display:none" />

      <!-- Карусель -->
      <div id="carouselWrap" class="carouselWrap">
        <div class="carouselHeader">
          <div class="chip" id="pagesCount">Добавлено: 0</div>
          <div class="chip" id="pageIndex">Страница: 0 / 0</div>
        </div>
        <div id="carousel" class="carousel"></div>
      </div>

      <!-- Подсказка при 0 страниц -->
      <div id="zeroHint" class="hintBox">
        Для анализа, пожалуйста, добавьте файл.
      </div>

      <!-- Панель качества (bad или warn) -->
      <div id="qualityGate" class="panel">
        <div id="qualityTitle" class="panelTitle">Проверка качества страниц</div>
        <div id="qualityText" class="panelText"></div>
        <div class="panelActions">
          <button id="showBadBtn" class="btn" type="button">Показать нечитаемые</button>
          <button id="deleteBadBtn" class="btn" type="button">Удалить нечитаемые</button>
          <button id="showWarnBtn" class="btn" type="button">Показать частично распознанные</button>
        </div>
        <div class="smallNote" id="qualityNote">
          Переснимите/замените отмеченные страницы. Это нужно, чтобы результат был точным и полным.
        </div>
      </div>

      <!-- Кнопка финального запуска -->
      <button id="analyzeBtn" class="btnPrimary" type="button" style="margin-top:12px;" disabled>
        Готово → Анализ
      </button>

      <!-- Прогресс -->
      <div id="progressBox" class="progressBox">
        <div class="progressRow">
          <div class="ring" aria-hidden="true"></div>
          <div class="progressText">
            <div id="pLine1" class="t1">Анализ идёт</div>
            <div id="pLine2" class="t2">Контролируем содержание письма</div>
          </div>
        </div>
        <div id="lockNote" class="lockNote">
          Во время анализа добавление и удаление страниц временно недоступны.
        </div>
      </div>

      <!-- Результат -->
      <div id="resultBox" class="panel">
        <div id="doneBanner" style="display:none; margin-bottom:10px;">
          <div style="font-weight:900;">Анализ завершён</div>
          <div style="opacity:0.95; margin-top:2px;">Ниже — результат проверки письма</div>
        </div>

        <div id="resultTitle" class="panelTitle"></div>
        <div id="resultSupport" class="panelText" style="margin-bottom:10px;"></div>
        <div id="resultDetails" class="panelText"></div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.14);">
          <div class="panelTitle">Кратко о письме</div>
          <div id="aboutText" class="panelText"></div>
        </div>

        <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,255,255,0.14);">
          <div class="panelTitle">Перевод (следующий этап)</div>
          <div class="panelText">
            Независимо от результата мы добавим понятный перевод и объяснение письма.
            Это будет подключено на следующем этапе через AI (после стабилизации входа и многостраничности).
          </div>
        </div>
      </div>

      <div class="footer">
        <small class="muted">
          v1.5 · thumbnails + ocrBlob · warn/bad · quality gate A · single worker · yield · no full rerender
        </small>
      </div>
    </div>
  </div>

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // Telegram init (safe)
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg) { try { tg.ready(); tg.expand(); } catch(e) {} }

    // --- Config (MVP limits) ---
    const MAX_PAGES = 15;
    document.getElementById("maxPagesText").textContent = String(MAX_PAGES);

    // DOM
    const cameraBtn = document.getElementById("cameraBtn");
    const filesBtn  = document.getElementById("filesBtn");
    const cameraInput = document.getElementById("cameraInput");
    const filesInput  = document.getElementById("filesInput");

    const carouselWrap = document.getElementById("carouselWrap");
    const carousel = document.getElementById("carousel");
    const pagesCount = document.getElementById("pagesCount");
    const pageIndex = document.getElementById("pageIndex");

    const analyzeBtn = document.getElementById("analyzeBtn");
    const zeroHint = document.getElementById("zeroHint");

    const progressBox = document.getElementById("progressBox");
    const pLine1 = document.getElementById("pLine1");
    const pLine2 = document.getElementById("pLine2");

    const qualityGate = document.getElementById("qualityGate");
    const qualityTitle = document.getElementById("qualityTitle");
    const qualityText = document.getElementById("qualityText");
    const qualityNote = document.getElementById("qualityNote");
    const showBadBtn = document.getElementById("showBadBtn");
    const deleteBadBtn = document.getElementById("deleteBadBtn");
    const showWarnBtn = document.getElementById("showWarnBtn");

    const resultBox = document.getElementById("resultBox");
    const doneBanner = document.getElementById("doneBanner");
    const resultTitle = document.getElementById("resultTitle");
    const resultSupport = document.getElementById("resultSupport");
    const resultDetails = document.getElementById("resultDetails");
    const aboutText = document.getElementById("aboutText");

    // State
    // pageObj:
    // { id, file:null, thumbUrl, ocrBlob, bad, badReason, warn, warnReason, ocrText, ocrConfidence }
    const pages = [];
    let isLocked = false;

    // One worker for whole analysis
    let ocrWorker = null;

    // ---------- Helpers ----------
    function uid() {
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    function nextFrame() {
      return new Promise(r => requestAnimationFrame(() => r()));
    }

    function hasBadPages() {
      return pages.some(p => p.bad);
    }

    function hasWarnPages() {
      return pages.some(p => p.warn && !p.bad);
    }

    function getBadIndexes() {
      return pages.map((p,i)=>p.bad ? (i+1) : null).filter(Boolean);
    }

    function getWarnIndexes() {
      return pages.map((p,i)=>(p.warn && !p.bad) ? (i+1) : null).filter(Boolean);
    }

    function firstBadIndex() {
      return pages.findIndex(p => p.bad);
    }

    function firstWarnIndex() {
      return pages.findIndex(p => p.warn && !p.bad);
    }

    function setLocked(v) {
      isLocked = v;
      cameraBtn.disabled = v;
      filesBtn.disabled = v;

      // analyze enabled only if: unlocked, pages exist, no bad pages
      analyzeBtn.disabled = v || pages.length === 0 || hasBadPages();

      // block delete buttons
      carousel.querySelectorAll("button[data-del]").forEach(btn => btn.disabled = v);
    }

    function showZeroHintIfNeeded() {
      zeroHint.style.display = pages.length === 0 ? "block" : "none";
      analyzeBtn.disabled = isLocked || pages.length === 0 || hasBadPages();
    }

    function updateCounters() {
      pagesCount.textContent = "Добавлено: " + pages.length;
      if (pages.length === 0) {
        pageIndex.textContent = "Страница: 0 / 0";
        return;
      }
      const idx = getVisibleIndex();
      pageIndex.textContent = "Страница: " + (idx + 1) + " / " + pages.length;
    }

    function getVisibleIndex() {
      if (!pages.length) return 0;
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      if (!slides.length) return 0;
      const left = carousel.scrollLeft;
      let best = 0;
      let bestDist = Infinity;
      slides.forEach((s, i) => {
        const dist = Math.abs(s.offsetLeft - left);
        if (dist < bestDist) { bestDist = dist; best = i; }
      });
      return best;
    }

    function scrollToPage(index) {
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      const s = slides[index];
      if (!s) return;
      carousel.scrollTo({ left: s.offsetLeft, behavior: "smooth" });
    }

    function updateSlideByIndex(idx) {
      const slide = carousel.querySelectorAll(".slide")[idx];
      if (!slide) return;

      slide.classList.remove("bad", "warn");
      if (pages[idx].bad) slide.classList.add("bad");
      else if (pages[idx].warn) slide.classList.add("warn");

      const badNote = slide.querySelector(".badNote");
      if (badNote) badNote.textContent = pages[idx].badReason || "Страница нечитаема. Переснимите/замените для точного результата.";

      const warnNote = slide.querySelector(".warnNote");
      if (warnNote) warnNote.textContent = pages[idx].warnReason || "Текст распознан частично. Для точности лучше переснять страницу.";
    }

    function renderCarousel() {
      carousel.innerHTML = "";

      if (pages.length === 0) {
        carouselWrap.style.display = "none";
        updateCounters();
        showZeroHintIfNeeded();
        return;
      }

      carouselWrap.style.display = "block";

      pages.forEach((p, idx) => {
        const slide = document.createElement("div");
        slide.className = "slide" + (p.bad ? " bad" : (p.warn ? " warn" : ""));
        slide.dataset.id = p.id;

        const img = document.createElement("img");
        img.src = p.thumbUrl;
        img.alt = "Страница " + (idx + 1);

        const meta = document.createElement("div");
        meta.className = "slideMeta";

        const pageNo = document.createElement("div");
        pageNo.className = "pageNo";
        pageNo.textContent = "Стр. " + (idx + 1);

        const del = document.createElement("button");
        del.className = "delBtn";
        del.type = "button";
        del.textContent = "Удалить";
        del.dataset.del = p.id;
        del.disabled = isLocked;
        del.addEventListener("click", () => {
          if (isLocked) return;
          removePage(p.id);
        });

        meta.appendChild(pageNo);
        meta.appendChild(del);

        const badNote = document.createElement("div");
        badNote.className = "badNote";
        badNote.textContent = p.badReason || "Страница нечитаема. Переснимите/замените для точного результата.";

        const warnNote = document.createElement("div");
        warnNote.className = "warnNote";
        warnNote.textContent = p.warnReason || "Текст распознан частично. Для точности лучше переснять страницу.";

        slide.appendChild(img);
        slide.appendChild(meta);
        slide.appendChild(badNote);
        slide.appendChild(warnNote);

        carousel.appendChild(slide);
      });

      updateCounters();
      showZeroHintIfNeeded();
    }

    function removePage(id) {
      const i = pages.findIndex(p => p.id === id);
      if (i >= 0) {
        try { URL.revokeObjectURL(pages[i].thumbUrl); } catch(e) {}
        // ocrBlob doesn't need revoke
        pages.splice(i, 1);
      }

      updateQualityPanel();
      renderCarousel();

      resultBox.style.display = "none";
      progressBox.style.display = "none";
    }

    function showLimitHint() {
      // Simple UI feedback via Telegram haptic / alert if possible; fallback to alert
      const msg = "Для стабильной работы максимум " + MAX_PAGES + " страниц за один анализ.";
      if (tg && tg.showPopup) {
        try {
          tg.showPopup({ title: "Лимит страниц", message: msg, buttons: [{type:"ok"}] });
          return;
        } catch(e) {}
      }
      alert(msg);
    }

    // ---------- Image prep: thumbUrl + ocrBlob (file removed) ----------
    async function createThumbAndOcr(file) {
      // Load image
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.src = url;

      await new Promise((res, rej) => {
        img.onload = () => res();
        img.onerror = () => rej(new Error("Image load failed"));
      });

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;

      function toJpegBlob(maxSide, quality) {
        const scale = Math.min(1, maxSide / Math.max(w, h));
        const nw = Math.max(1, Math.round(w * scale));
        const nh = Math.max(1, Math.round(h * scale));

        const canvas = document.createElement("canvas");
        canvas.width = nw;
        canvas.height = nh;
        const ctx = canvas.getContext("2d", { alpha: false });
        ctx.drawImage(img, 0, 0, nw, nh);

        return new Promise((resolve) => {
          canvas.toBlob((blob) => resolve(blob), "image/jpeg", quality);
        });
      }

      const thumbBlob = await toJpegBlob(650, 0.75);
      const ocrBlob   = await toJpegBlob(1800, 0.82);

      URL.revokeObjectURL(url);

      if (!thumbBlob || !ocrBlob) {
        // Return nulls so caller can mark as bad
        return { thumbUrl: "", ocrBlob: null };
      }

      const thumbUrl = URL.createObjectURL(thumbBlob);
      return { thumbUrl, ocrBlob };
    }

    async function addFiles(fileList) {
      const arr = Array.from(fileList || []);
      if (!arr.length) return;

      for (const f of arr) {
        if (!f || !f.type || !f.type.startsWith("image/")) continue;
        if (pages.length >= MAX_PAGES) { showLimitHint(); break; }

        const { thumbUrl, ocrBlob } = await createThumbAndOcr(f);

        pages.push({
          id: uid(),
          file: null,         // IMPORTANT: we do not store original file
          thumbUrl: thumbUrl,
          ocrBlob: ocrBlob,

          bad: false,
          badReason: "",
          warn: false,
          warnReason: "",

          ocrText: "",
          ocrConfidence: null
        });
      }

      cameraInput.value = "";
      filesInput.value = "";

      // Hide panels on new add
      resultBox.style.display = "none";
      progressBox.style.display = "none";

      renderCarousel();
      updateQualityPanel();
    }

    // ---------- OCR text cleanup ----------
    function cleanOcrText(t) {
      let s = (t || "");
      s = s.replace(/[^\S\r\n]+/g, " ");
      s = s.replace(/\n{3,}/g, "\n\n");
      s = s.replace(/[|}{]{2,}/g, " ");
      // keep letters/numbers/punct
      s = s.replace(/[^\p{L}\p{N}\s.,:;!?()+\-\/€$@%]/gu, "");
      s = s.replace(/\s{2,}/g, " ").trim();
      return s;
    }

    function normalize(s) {
      return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
    }

    // ---------- Page quality evaluation (Balanced) ----------
    function evaluatePageQuality(text, confidence) {
      const t = text || "";
      const textLen = t.length;

      const ns = t.replace(/\s+/g, "");
      const total = Math.max(1, ns.length);
      const alphaNum = (ns.match(/[A-Za-zА-Яа-я0-9ÄÖÜäöüß]/g) || []).length;
      const alphaNumRatio = alphaNum / total;

      const low = normalize(t);

      const keyPatterns = [
        "termin","einladung","frist","bis zum","spätestens",
        "bitte","wir bitten","sie werden gebeten",
        "unterlagen","nachweis","nachweisen","einreichen","vorlegen","mitwirkung",
        "anhörung","aufforderung","fehlende unterlagen","formular","ausfüllen"
      ];

      const hasKeySignals = keyPatterns.some(k => low.includes(k));

      // Balanced thresholds
      const confBad = (confidence !== null && typeof confidence === "number" && confidence < 55);
      const ratioBad = (alphaNumRatio < 0.50);
      const tooShort = (textLen < 80);

      // WARN: short but contains key signals (do not block)
      if (tooShort && hasKeySignals && !confBad && !ratioBad) {
        return {
          status: "warn",
          reason: "Текст распознан частично, но найдены сигналы действия. Для точности лучше переснять страницу.",
          metrics: { textLen, confidence, alphaNumRatio, hasKeySignals }
        };
      }

      // BAD: hard reasons (block)
      if (confBad || ratioBad || (tooShort && !hasKeySignals)) {
        let reason = "Страница нечитаема. Переснимите или удалите — иначе результат будет неточным.";

        if (confBad && tooShort) reason = "Страница распознана плохо (мало текста и низкое качество). Переснимите или удалите.";
        else if (confBad) reason = "Качество распознавания низкое. Переснимите или удалите.";
        else if (ratioBad) reason = "Текст распознан с большим количеством ошибок. Переснимите или удалите.";
        else if (tooShort && !hasKeySignals) reason = "На странице почти не удалось распознать текст. Переснимите или удалите.";

        return {
          status: "bad",
          reason,
          metrics: { textLen, confidence, alphaNumRatio, hasKeySignals }
        };
      }

      // OK
      return {
        status: "ok",
        reason: "",
        metrics: { textLen, confidence, alphaNumRatio, hasKeySignals }
      };
    }

    // ---------- OCR worker (single) ----------
    async function getOcrWorker() {
      if (ocrWorker) return ocrWorker;
      ocrWorker = await Tesseract.createWorker("deu+rus");
      return ocrWorker;
    }

    async function closeOcrWorker() {
      if (!ocrWorker) return;
      try { await ocrWorker.terminate(); } catch (e) {}
      ocrWorker = null;
    }

    // ---------- OCR one page ----------
    async function ocrOnePage(pageObj, idx, total) {
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Обрабатываем страницы: " + (idx + 1) + " из " + total;

      if (!pageObj.ocrBlob) {
        // Could not prepare image
        pageObj.bad = true;
        pageObj.badReason = "Не удалось подготовить изображение для анализа. Переснимите страницу и добавьте снова.";
        pageObj.warn = false;
        pageObj.warnReason = "";
        pageObj.ocrText = "";
        pageObj.ocrConfidence = null;
        return;
      }

      const worker = await getOcrWorker();
      const { data } = await worker.recognize(pageObj.ocrBlob);

      const rawText = (data && data.text) ? data.text : "";
      const cleaned = cleanOcrText(rawText);
      const confidence = (data && typeof data.confidence === "number") ? data.confidence : null;

      pageObj.ocrText = cleaned;
      pageObj.ocrConfidence = confidence;

      const q = evaluatePageQuality(cleaned, confidence);

      if (q.status === "bad") {
        pageObj.bad = true;
        pageObj.badReason = q.reason;
        pageObj.warn = false;
        pageObj.warnReason = "";
      } else if (q.status === "warn") {
        pageObj.bad = false;
        pageObj.badReason = "";
        pageObj.warn = true;
        pageObj.warnReason = q.reason;
      } else {
        pageObj.bad = false;
        pageObj.badReason = "";
        pageObj.warn = false;
        pageObj.warnReason = "";
      }
    }

    // ---------- Analysis (rule-based, no “maybe”) ----------
    function findDeadline(text) {
      const m1 = text.match(/\b(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m1) return m1[1];
      const m2 = text.match(/\b(bis zum|spätestens am|frist|fristen|bis spätestens)\s+(\d{1,2}\.\d{1,2}\.\d{2,4})\b/i);
      if (m2) return m2[2];
      return "";
    }

    function analyzeText(raw) {
      const t = normalize(raw);
      if (t.length < 100) return { kind: "insufficient", deadline: "", signals: [] };

      const signalsAction = [
        "bitte","wir bitten","sie werden gebeten","sie sind verpflichtet",
        "erforderlich","nachweisen","nachweis","einreichen","vorlegen",
        "termin","einladung","melden sie sich","rückmeldung",
        "frist","bis zum","spätestens","umgehend",
        "anhörung","mitwirkung","aufforderung","fehlende unterlagen",
        "unterlagen","kontoauszüge","mietvertrag","ausfüllen","formular"
      ];

      const found = signalsAction.filter(w => t.includes(w));
      const deadline = findDeadline(t);

      if (found.length >= 2 || (found.length >= 1 && (t.includes("frist") || t.includes("termin") || deadline))) {
        return { kind: "needAction", deadline, signals: found.slice(0, 6) };
      }

      return { kind: "noAction", deadline: "", signals: [] };
    }

    function aboutLetter(raw) {
      const t = normalize(raw);
      if (t.length < 100) {
        return "Текста недостаточно для уверенного вывода. Добавьте страницу с основной частью письма (где указаны просьбы, сроки или термин).";
      }
      const hasTermin = /termin|einladung|melden sie sich|vorsprechen/.test(t);
      const hasDocs = /unterlagen|nachweis|nachweisen|einreichen|vorlegen|mitwirkung|aufforderung|fehlende|ausfüllen|formular/.test(t);
      const hasPay = /bürgergeld|zahlung|auszahlung|betrag|überweisung|monatlich/.test(t);
      const hasBescheid = /bescheid|änderungsbescheid|bewilligung|bewilligungsbescheid|mitteilung|veränderungsmitteilung/.test(t);

      if (hasTermin) return "В письме обнаружены слова, связанные с термином/встречей. Обычно это означает необходимость прийти или ответить.";
      if (hasDocs) return "В письме обнаружены слова, связанные с документами/подтверждениями. Обычно это означает необходимость предоставить документы.";
      if (hasPay) return "В письме обнаружены слова, связанные с выплатами/суммами. Часто это информирование о расчётах.";
      if (hasBescheid) return "В письме обнаружены слова, связанные с решением/уведомлением (Bescheid). Проверьте, есть ли сроки или просьбы.";
      return "Письмо содержит общий текст. Для точности важны страницы со сроками/просьбами (Bitte / Frist / Termin).";
    }

    function showResult(res, combinedText) {
      doneBanner.style.display = "block";

      // WARN banner in result if exists
      const warnPages = getWarnIndexes();
      const warnLineNeed = warnPages.length
        ? ("Внимание: страницы " + warnPages.join(", ") + " распознаны частично. Сигналы действия найдены. Для точности лучше переснять эти страницы.")
        : "";

      const warnLineNo = warnPages.length
        ? ("Внимание: страницы " + warnPages.join(", ") + " распознаны частично. Если вы ожидаете запрос документов или Termin — переснимите эти страницы и повторите анализ.")
        : "";

      if (res.kind === "needAction") {
        resultTitle.textContent = "✅ Требуется действие";
        resultSupport.textContent = (warnLineNeed ? (warnLineNeed + "\n\n") : "") +
          "Ниже — пояснение, что именно требуется.";

        const sig = res.signals.length ? ("Найдены сигналы: " + res.signals.join(", ") + "\n") : "";
        const dl = res.deadline ? ("Срок, указанный в тексте: " + res.deadline + "\n") : "";

        resultDetails.textContent =
          sig + dl +
          "Что сделать:\n" +
          "• проверьте, просят ли предоставить документы (Unterlagen / Nachweis),\n" +
          "• или прийти/ответить по термину (Termin / Einladung),\n" +
          "• или заполнить форму (Formular / ausfüllen).\n\n" +
          "Если в письме есть Bitte / Frist / Termin — это прямой сигнал к действию.";
      }
      else if (res.kind === "noAction") {
        resultTitle.textContent = "❌ Действие не требуется";
        resultSupport.textContent = (warnLineNo ? (warnLineNo + "\n\n") : "") +
          "В распознанном тексте не обнаружены просьбы: прислать документы, ответить или прийти в термин.";

        resultDetails.textContent =
          "Что это значит:\n" +
          "• письмо выглядит как информационное уведомление (без обязательных действий).\n" +
          "• если вы ожидаете запрос документов или приглашение — проверьте, не пропущена ли какая-то страница.\n";
      }
      else {
        resultTitle.textContent = "⚠️ Недостаточно данных";
        resultSupport.textContent =
          "Текст распознан частично или отсутствуют ключевые фразы. Добавьте/переснимите страницу с основной частью письма.";

        resultDetails.textContent =
          "Как исправить:\n" +
          "• снимите страницу ближе (текст должен занимать 70–90% кадра)\n" +
          "• уберите блики/тени\n" +
          "• добавьте страницу со словами Bitte / Frist / Termin (если они есть)\n";
      }

      aboutText.textContent = aboutLetter(combinedText);

      resultBox.style.display = "block";
    }

    // ---------- Quality panel (bad blocks, warn informs) ----------
    function updateQualityPanel() {
      const badIdx = getBadIndexes();
      const warnIdx = getWarnIndexes();

      // Buttons state
      showBadBtn.disabled = badIdx.length === 0;
      deleteBadBtn.disabled = isLocked || badIdx.length === 0;
      showWarnBtn.disabled = warnIdx.length === 0;

      if (badIdx.length === 0 && warnIdx.length === 0) {
        qualityGate.style.display = "none";
        qualityText.textContent = "";
        analyzeBtn.disabled = isLocked || pages.length === 0;
        return;
      }

      qualityGate.style.display = "block";

      if (badIdx.length > 0) {
        // HARD mode: block analysis
        qualityTitle.textContent = "Обнаружены нечитаемые страницы";
        qualityText.textContent =
          "Нечитаемые страницы: " + badIdx.join(", ") + "\n" +
          "Чтобы анализ был точным, переснимите или удалите их.";

        qualityNote.textContent =
          "Переснимите/замените отмеченные страницы и повторите анализ. Это нужно, чтобы результат был точным и полным.";

        analyzeBtn.disabled = true;
      } else {
        // SOFT mode: warn only, analysis allowed
        qualityTitle.textContent = "Есть частично распознанные страницы";
        qualityText.textContent =
          "Страницы: " + warnIdx.join(", ") + "\n" +
          "Анализ возможен. Для точности лучше переснять эти страницы.";

        qualityNote.textContent =
          "Это не блокирует анализ. Если результат важен — переснимите страницы с предупреждением.";

        analyzeBtn.disabled = isLocked || pages.length === 0;
      }
    }

    // Buttons: show / delete bad, show warn
    showBadBtn.addEventListener("click", () => {
      const i = firstBadIndex();
      if (i >= 0) scrollToPage(i);
    });

    deleteBadBtn.addEventListener("click", () => {
      if (isLocked) return;
      const toRemove = pages.filter(p => p.bad).map(p => p.id);
      toRemove.forEach(id => removePage(id));
      updateQualityPanel();
      renderCarousel();
    });

    showWarnBtn.addEventListener("click", () => {
      const i = firstWarnIndex();
      if (i >= 0) scrollToPage(i);
    });

    // ---------- Events ----------
    cameraBtn.addEventListener("click", () => {
      if (isLocked) return;
      cameraInput.click();
    });

    filesBtn.addEventListener("click", () => {
      if (isLocked) return;
      filesInput.click();
    });

    cameraInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(cameraInput.files);
    });

    filesInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(filesInput.files);
    });

    carousel.addEventListener("scroll", () => updateCounters());

    analyzeBtn.addEventListener("click", async () => {
      if (isLocked) return;
      if (pages.length === 0) { showZeroHintIfNeeded(); return; }
      if (hasBadPages()) { updateQualityPanel(); return; }

      // Start analysis
      setLocked(true);
      resultBox.style.display = "none";
      doneBanner.style.display = "none";

      progressBox.style.display = "block";
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Контролируем содержание письма";

      try {
        // OCR all pages (sequential)
        for (let i = 0; i < pages.length; i++) {
          await ocrOnePage(pages[i], i, pages.length);

          // Update only one slide (no heavy rerender)
          updateSlideByIndex(i);
          updateCounters();

          // Update quality panel state progressively
          updateQualityPanel();

          // Give UI a frame
          await nextFrame();
        }

        // After OCR: if bad pages exist => gate A blocks
        updateQualityPanel();
        if (hasBadPages()) {
          progressBox.style.display = "none";
          setLocked(false);
          showZeroHintIfNeeded();

          const i = firstBadIndex();
          if (i >= 0) scrollToPage(i);

          await closeOcrWorker();
          return;
        }

        // Pre-result
        pLine1.textContent = "Анализ идёт";
        pLine2.textContent = "Проверяем, требуется ли от вас действие";
        await nextFrame();

        const combinedText = pages
          .map((p, idx) => `--- Страница ${idx + 1} ---\n${p.ocrText || ""}`)
          .join("\n\n");

        const res = analyzeText(combinedText);

        // Finish
        pLine1.textContent = "Анализ завершён";
        pLine2.textContent = "Ниже — результат проверки письма";

        setTimeout(async () => {
          showResult(res, combinedText);
          progressBox.style.display = "none";
          setLocked(false);
          showZeroHintIfNeeded();

          await closeOcrWorker();
        }, 250);

      } catch (e) {
        progressBox.style.display = "none";
        setLocked(false);
        showZeroHintIfNeeded();

        resultBox.style.display = "block";
        doneBanner.style.display = "none";

        resultTitle.textContent = "⚠️ Не удалось завершить анализ";
        resultSupport.textContent = "Переснимите страницы ближе и попробуйте ещё раз.";
        resultDetails.textContent =
          "Рекомендации:\n" +
          "• текст должен занимать 70–90% кадра\n" +
          "• без бликов и теней\n" +
          "• добавьте страницы с Bitte / Frist / Termin, если они есть\n";
        aboutText.textContent = "—";

        await closeOcrWorker();
      }
    });

    // init
    renderCarousel();
    updateQualityPanel();
    showZeroHintIfNeeded();
  </script>
</body>
</html>
