<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Jobcenter Letter Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="badge">Telegram Mini App · MVP</div>
      <h1 id="title">Проверка письма Jobcenter</h1>
      <p id="subtitle" class="subtitle">Помогаем понять, требуется ли действие по письму.</p>
    </div>

    <div class="card">
      <p id="disclaimer" class="disclaimer">
        Это не юридическая консультация. Сервис показывает только: нужно ли действие по письму.
      </p>

      <div class="actionsRow">
        <button id="cameraBtn" class="btn" type="button">Сделать фото</button>
        <button id="filesBtn" class="btn" type="button">Выбрать файлы</button>
      </div>

      <div class="smallNote">
        <b>Важно:</b> PDF в Telegram Mini App часто не обрабатывается. Для надёжного результата используйте фото/скрин страниц письма.<br>
        <b>Лимит:</b> максимум <span id="maxPagesText">15</span> страниц за один анализ.
      </div>

      <input id="cameraInput" type="file" accept="image/*" capture="environment" style="display:none" />
      <input id="filesInput"  type="file" accept="image/*" multiple style="display:none" />

      <!-- Карусель -->
      <div id="carouselWrap" class="carouselWrap">
        <div class="carouselHeader">
          <div class="chip" id="pagesCount">Добавлено: 0</div>
          <div class="chip" id="pageIndex">Страница: 0 / 0</div>
        </div>
        <div id="carousel" class="carousel"></div>
      </div>

      <!-- Подсказка при 0 страниц -->
      <div id="zeroHint" class="hintBox">
        Для анализа, пожалуйста, добавьте файл.
      </div>

      <!-- Подсказка при превышении лимита -->
      <div id="limitHint" class="hintBox">
        Достигнут лимит страниц для одного анализа. Добавьте меньше страниц или сделайте второй анализ.
      </div>

      <!-- Панель качества (BAD/WARN) -->
      <div id="qualityPanel" class="panel">
        <div id="qualityTitle" class="panelTitle"></div>
        <div id="qualityText" class="panelText"></div>

        <div class="panelActions">
          <button id="showBadBtn" class="btn" type="button">Показать нечитаемые</button>
          <button id="deleteCurrentBadBtn" class="btn" type="button">Удалить текущую bad страницу</button>
          <button id="deleteBadBtn" class="btn" type="button">Удалить нечитаемые</button>
          <button id="showWarnBtn" class="btn" type="button">Показать частично распознанные</button>
        </div>

        <div class="smallNote">
          Если страницы помечены как нечитаемые — анализ блокируется, чтобы результат был точным.
          Частично распознанные страницы анализ не блокируют, но могут снижать точность.
        </div>

        <!-- Список bad/warn страниц -->
        <div id="qualityList" class="pageList"></div>
      </div>

      <!-- Кнопка запуска -->
      <button id="analyzeBtn" class="btnPrimary" type="button" disabled>
        Готово → Анализ
      </button>

      <!-- Прогресс -->
      <div id="progressBox" class="progressBox">
        <div class="progressRow">
          <div class="ring" aria-hidden="true"></div>
          <div class="progressText">
            <div id="pLine1" class="t1">Анализ идёт</div>
            <div id="pLine2" class="t2">Контролируем содержание письма</div>
          </div>
        </div>
        <div id="lockNote" class="lockNote">
          Во время анализа добавление и удаление страниц временно недоступны.
        </div>
      </div>

      <!-- Результат -->
      <div id="resultBox" class="panel">
        <div id="doneBanner" class="doneBanner">
          <div class="doneTitle">Анализ завершён</div>
          <div class="doneSub">Ниже — результат проверки письма</div>
        </div>

        <div id="resultTitle" class="panelTitle"></div>
        <div id="resultSupport" class="panelText" style="margin-bottom:10px;"></div>
        <div id="resultDetails" class="panelText"></div>

        <div class="sectionDivider"></div>

        <div class="panelTitle">Кратко о письме</div>
        <div id="aboutText" class="panelText"></div>

        <div class="sectionDivider"></div>

        <div class="panelTitle">Перевод (следующий этап)</div>
        <div class="panelText">
          Независимо от результата мы добавим понятный перевод и объяснение письма.
          Это будет подключено на следующем этапе через AI (после стабилизации входа и многостраничности).
        </div>
      </div>

      <small class="version">
        v1.8 · iOS fix: progress+fast deu + auto deu+rus · +delete current bad · +bad/warn list · thumbnails+ocrBlob · warn/bad · quality panel · single worker · yield · no full rerender · max 15
      </small>
    </div>
  </div>

  <!-- Telegram Mini App SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // ---------------- Telegram init (safe) ----------------
    const tg = window.Telegram && window.Telegram.WebApp ? window.Telegram.WebApp : null;
    if (tg) { tg.ready(); tg.expand(); }

    // ---------------- Constants ----------------
    const MAX_PAGES = 15;
    document.getElementById("maxPagesText").textContent = String(MAX_PAGES);

    // OCR modes
    const OCR_LANG_FAST = "deu";
    const OCR_LANG_FULL = "deu+rus";

    // ---------------- DOM ----------------
    const cameraBtn = document.getElementById("cameraBtn");
    const filesBtn  = document.getElementById("filesBtn");
    const cameraInput = document.getElementById("cameraInput");
    const filesInput  = document.getElementById("filesInput");

    const carouselWrap = document.getElementById("carouselWrap");
    const carousel = document.getElementById("carousel");
    const pagesCount = document.getElementById("pagesCount");
    const pageIndex = document.getElementById("pageIndex");

    const analyzeBtn = document.getElementById("analyzeBtn");
    const zeroHint = document.getElementById("zeroHint");
    const limitHint = document.getElementById("limitHint");

    const progressBox = document.getElementById("progressBox");
    const pLine1 = document.getElementById("pLine1");
    const pLine2 = document.getElementById("pLine2");

    const qualityPanel = document.getElementById("qualityPanel");
    const qualityTitle = document.getElementById("qualityTitle");
    const qualityText = document.getElementById("qualityText");
    const showBadBtn = document.getElementById("showBadBtn");
    const deleteCurrentBadBtn = document.getElementById("deleteCurrentBadBtn");
    const deleteBadBtn = document.getElementById("deleteBadBtn");
    const showWarnBtn = document.getElementById("showWarnBtn");
    const qualityList = document.getElementById("qualityList");

    const resultBox = document.getElementById("resultBox");
    const doneBanner = document.getElementById("doneBanner");
    const resultTitle = document.getElementById("resultTitle");
    const resultSupport = document.getElementById("resultSupport");
    const resultDetails = document.getElementById("resultDetails");
    const aboutText = document.getElementById("aboutText");

    // ---------------- State ----------------
    // page: { id, thumbUrl, ocrBlob, status:'ok'|'warn'|'bad', reason:'', ocrText:'', ocrConfidence:null, metrics:{} }
    const pages = [];
    let isLocked = false;

    // single OCR worker
    let ocrWorker = null;
    let ocrLangInited = null;

    // ---------------- Helpers ----------------
    function uid() {
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    function nextFrame() {
      return new Promise(r => requestAnimationFrame(() => r()));
    }

    function normalize(s) {
      return (s || "").toLowerCase().replace(/\s+/g, " ").trim();
    }

    function hasBadPages() {
      return pages.some(p => p.status === "bad");
    }

    function badIndexes() {
      return pages.map((p,i) => p.status === "bad" ? (i+1) : null).filter(Boolean);
    }

    function warnIndexes() {
      return pages.map((p,i) => p.status === "warn" ? (i+1) : null).filter(Boolean);
    }

    function firstBadIndex() {
      return pages.findIndex(p => p.status === "bad");
    }

    function firstWarnIndex() {
      return pages.findIndex(p => p.status === "warn");
    }

    function setLocked(v) {
      isLocked = v;
      cameraBtn.disabled = v;
      filesBtn.disabled  = v;

      // delete buttons in slides
      carousel.querySelectorAll("button[data-del]").forEach(btn => btn.disabled = v);

      // quality panel buttons
      showBadBtn.disabled = v;
      deleteCurrentBadBtn.disabled = v;
      deleteBadBtn.disabled = v;
      showWarnBtn.disabled = v;

      // analyze: only if not locked, there are pages, and there are NO bad pages
      analyzeBtn.disabled = v || pages.length === 0 || hasBadPages();
    }

    function showZeroHintIfNeeded() {
      zeroHint.style.display = (pages.length === 0) ? "block" : "none";
      analyzeBtn.disabled = isLocked || pages.length === 0 || hasBadPages();
    }

    function showLimitHint(v) {
      limitHint.style.display = v ? "block" : "none";
    }

    function getVisibleIndex() {
      if (!pages.length) return 0;
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      if (!slides.length) return 0;
      const left = carousel.scrollLeft;
      let best = 0, bestDist = Infinity;
      slides.forEach((s, i) => {
        const dist = Math.abs(s.offsetLeft - left);
        if (dist < bestDist) { bestDist = dist; best = i; }
      });
      return best;
    }

    function updateCounters() {
      pagesCount.textContent = "Добавлено: " + pages.length;
      if (pages.length === 0) pageIndex.textContent = "Страница: 0 / 0";
      else pageIndex.textContent = "Страница: " + (getVisibleIndex()+1) + " / " + pages.length;
    }

    function scrollToPage(index) {
      const slides = Array.from(carousel.querySelectorAll(".slide"));
      const s = slides[index];
      if (!s) return;
      carousel.scrollTo({ left: s.offsetLeft, behavior: "smooth" });
    }

    function escapeHtml(s) {
      return String(s || "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // ---------------- Rendering ----------------
    function renderCarousel() {
      carousel.innerHTML = "";

      if (pages.length === 0) {
        carouselWrap.style.display = "none";
        updateCounters();
        showZeroHintIfNeeded();
        return;
      }

      carouselWrap.style.display = "block";

      pages.forEach((p, idx) => {
        const slide = document.createElement("div");
        slide.className = "slide " + p.status;
        slide.dataset.id = p.id;

        const img = document.createElement("img");
        img.src = p.thumbUrl;
        img.alt = "Страница " + (idx + 1);

        const meta = document.createElement("div");
        meta.className = "slideMeta";

        const pageNo = document.createElement("div");
        pageNo.className = "pageNo";
        pageNo.textContent = "Стр. " + (idx + 1);

        const del = document.createElement("button");
        del.className = "delBtn";
        del.type = "button";
        del.textContent = "Удалить";
        del.dataset.del = p.id;
        del.disabled = isLocked;
        del.addEventListener("click", () => {
          if (isLocked) return;
          removePage(p.id);
        });

        meta.appendChild(pageNo);
        meta.appendChild(del);

        const badNote = document.createElement("div");
        badNote.className = "badNote";
        badNote.textContent = p.reason || "Качество распознавания низкое. Переснимите или удалите страницу.";

        const warnNote = document.createElement("div");
        warnNote.className = "warnNote";
        warnNote.textContent = p.reason || "Текст распознан частично. Для точности лучше переснять страницу.";

        slide.appendChild(img);
        slide.appendChild(meta);
        slide.appendChild(badNote);
        slide.appendChild(warnNote);

        carousel.appendChild(slide);
      });

      updateCounters();
      showZeroHintIfNeeded();
    }

    function updateSlideByIndex(idx) {
      const slide = carousel.querySelectorAll(".slide")[idx];
      if (!slide) return;

      slide.classList.remove("ok","warn","bad");
      slide.classList.add(pages[idx].status);

      const badNote = slide.querySelector(".badNote");
      const warnNote = slide.querySelector(".warnNote");

      if (badNote) badNote.textContent = pages[idx].reason || "Качество распознавания низкое. Переснимите или удалите страницу.";
      if (warnNote) warnNote.textContent = pages[idx].reason || "Текст распознан частично. Для точности лучше переснять страницу.";
    }

    // ---------------- Quality List ----------------
    function renderQualityList() {
      if (!qualityList) return;

      qualityList.style.display = "none";
      qualityList.innerHTML = "";

      if (pages.length === 0) return;

      const rows = [];

      pages.forEach((p, i) => {
        if (p.status !== "bad" && p.status !== "warn") return;

        const tag = (p.status === "bad") ? "BAD" : "WARN";
        const reason = (p.reason || "").trim() || (
          p.status === "bad"
            ? "Качество распознавания низкое. Переснимите или удалите страницу."
            : "Текст распознан частично. Для точности лучше переснять страницу."
        );

        rows.push(`
          <div class="pageListRow">
            <div class="pageTag ${p.status}">${tag}</div>
            <div class="pageListText"><b>Страница ${i + 1}</b><br>${escapeHtml(reason)}</div>
          </div>
        `);
      });

      if (rows.length === 0) return;

      qualityList.innerHTML = rows.join("");
      qualityList.style.display = "flex";
    }

    // ---------------- Quality Panel (BAD/WARN) ----------------
    function updateQualityPanel() {
      // hide by default
      qualityPanel.style.display = "none";

      // always refresh list (it will hide itself if no rows)
      renderQualityList();

      if (pages.length === 0) return;

      const bad = badIndexes();
      const warn = warnIndexes();

      // 1) BAD present => show BAD panel, block analyze
      if (bad.length > 0) {
        qualityPanel.style.display = "block";
        qualityTitle.textContent = "Обнаружены нечитаемые страницы";
        qualityText.textContent =
          "Нечитаемые страницы: " + bad.join(", ") + "\n" +
          "Чтобы анализ был точным, переснимите или удалите их.";

        showBadBtn.style.display = "inline-flex";
        deleteCurrentBadBtn.style.display = "inline-flex";
        deleteBadBtn.style.display = "inline-flex";
        showWarnBtn.style.display = (warn.length > 0) ? "inline-flex" : "none";

        // lock-aware enabling
        showBadBtn.disabled = isLocked;
        deleteCurrentBadBtn.disabled = isLocked;
        deleteBadBtn.disabled = isLocked;
        showWarnBtn.disabled = isLocked;

        analyzeBtn.disabled = true; // блокируем при bad
        return;
      }

      // 2) No BAD, but WARN => show WARN panel (not blocking)
      if (warn.length > 0) {
        qualityPanel.style.display = "block";
        qualityTitle.textContent = "Есть частично распознанные страницы";
        qualityText.textContent =
          "Страницы: " + warn.join(", ") + "\n" +
          "Анализ возможен, но для максимальной точности лучше переснять эти страницы.";

        showBadBtn.style.display = "none";
        deleteCurrentBadBtn.style.display = "none";
        deleteBadBtn.style.display = "none";
        showWarnBtn.style.display = "inline-flex";

        showWarnBtn.disabled = isLocked;

        analyzeBtn.disabled = isLocked || pages.length === 0; // warn не блокирует
        return;
      }

      // 3) No issues => panel hidden
      analyzeBtn.disabled = isLocked || pages.length === 0;
    }

    showBadBtn.addEventListener("click", () => {
      const i = firstBadIndex();
      if (i >= 0) scrollToPage(i);
    });

    showWarnBtn.addEventListener("click", () => {
      const i = firstWarnIndex();
      if (i >= 0) scrollToPage(i);
    });

    deleteCurrentBadBtn.addEventListener("click", () => {
      if (isLocked) return;
      if (pages.length === 0) return;

      const current = getVisibleIndex();
      if (current >= 0 && current < pages.length && pages[current].status === "bad") {
        const id = pages[current].id;
        removePage(id);
        updateQualityPanel();
        renderCarousel();
        return;
      }

      const fb = firstBadIndex();
      if (fb >= 0) {
        scrollToPage(fb);
        const id = pages[fb].id;
        removePage(id);
        updateQualityPanel();
        renderCarousel();
      }
    });

    deleteBadBtn.addEventListener("click", () => {
      if (isLocked) return;
      const ids = pages.filter(p => p.status === "bad").map(p => p.id);
      ids.forEach(id => removePage(id));
      updateQualityPanel();
      renderCarousel();
    });

    // ---------------- Remove page ----------------
    function removePage(id) {
      const i = pages.findIndex(p => p.id === id);
      if (i >= 0) {
        try { URL.revokeObjectURL(pages[i].thumbUrl); } catch(e) {}
        // ocrBlob освобождает GC
        pages.splice(i, 1);
      }
      resultBox.style.display = "none";
      progressBox.style.display = "none";
      showLimitHint(false);

      renderCarousel();
      updateQualityPanel();
      showZeroHintIfNeeded();
    }

    // ---------------- Image -> Blobs (thumb + ocrBlob) ----------------
    async function loadImageFromFile(file) {
      const url = URL.createObjectURL(file);
      try {
        const img = new Image();
        img.src = url;
        await new Promise((res, rej) => {
          img.onload = () => res();
          img.onerror = () => rej(new Error("Image load failed"));
        });
        return { img, url };
      } catch (e) {
        try { URL.revokeObjectURL(url); } catch(_) {}
        throw e;
      }
    }

    async function renderJpegBlob(img, maxSide, quality) {
      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      const scale = Math.min(1, maxSide / Math.max(w, h));
      const nw = Math.max(1, Math.round(w * scale));
      const nh = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement("canvas");
      canvas.width = nw;
      canvas.height = nh;
      const ctx = canvas.getContext("2d", { alpha: false });
      ctx.drawImage(img, 0, 0, nw, nh);

      const blob = await new Promise((resolve) => {
        canvas.toBlob((b) => resolve(b), "image/jpeg", quality);
      });

      if (!blob) throw new Error("toBlob failed");
      return blob;
    }

    async function createThumbAndOcr(file) {
      const { img, url } = await loadImageFromFile(file);
      try {
        const thumbBlob = await renderJpegBlob(img, 650, 0.75);
        const ocrBlob   = await renderJpegBlob(img, 1800, 0.82);

        const thumbUrl = URL.createObjectURL(thumbBlob);
        return { thumbUrl, ocrBlob };
      } finally {
        try { URL.revokeObjectURL(url); } catch(e) {}
      }
    }

    async function addFiles(fileList) {
      const arr = Array.from(fileList || []).filter(f => f && f.type && f.type.startsWith("image/"));
      if (!arr.length) return;

      // limit
      const free = MAX_PAGES - pages.length;
      if (free <= 0) {
        showLimitHint(true);
        return;
      }

      const slice = arr.slice(0, free);
      showLimitHint(arr.length > free);

      // reset result/panels when adding new files
      resultBox.style.display = "none";
      progressBox.style.display = "none";

      for (const f of slice) {
        const { thumbUrl, ocrBlob } = await createThumbAndOcr(f);

        pages.push({
          id: uid(),
          thumbUrl,
          ocrBlob,
          status: "ok",
          reason: "",
          ocrText: "",
          ocrConfidence: null,
          metrics: {}
        });
      }

      cameraInput.value = "";
      filesInput.value = "";

      renderCarousel();
      updateQualityPanel();
      showZeroHintIfNeeded();
    }

    // ---------------- OCR worker (with progress + fast lang) ----------------
    async function getOcrWorker(lang) {
      if (!lang) lang = OCR_LANG_FAST;

      if (!ocrWorker) {
        ocrWorker = await Tesseract.createWorker({
          logger: (m) => {
            const pct = (typeof m.progress === "number") ? Math.round(m.progress * 100) : null;
            pLine1.textContent = "Анализ идёт";
            pLine2.textContent = (pct !== null)
              ? `${m.status}: ${pct}%`
              : `${m.status}`;
          }
        });
      }

      if (ocrLangInited === lang) return ocrWorker;

      pLine1.textContent = "Подготовка OCR";
      pLine2.textContent = "Загружаем языки (первый запуск может занять время)";

      await ocrWorker.loadLanguage(lang);
      await ocrWorker.initialize(lang);

      ocrLangInited = lang;
      return ocrWorker;
    }

    async function closeOcrWorker() {
      if (!ocrWorker) return;
      try { await ocrWorker.terminate(); } catch(e) {}
      ocrWorker = null;
      ocrLangInited = null;
    }

    // ---------------- OCR cleaning ----------------
    function cleanOcrText(t) {
      let s = (t || "");
      s = s.replace(/[^\S\r\n]+/g, " ");
      s = s.replace(/\n{3,}/g, "\n\n");
      s = s.replace(/[|}{]{2,}/g, " ");
      s = s.replace(/[^\p{L}\p{N}\s.,:;!?()+\-\/€$@%]/gu, "");
      s = s.replace(/\s{2,}/g, " ").trim();
      return s;
    }

    // ---------------- Patch 1: Balanced quality evaluation ----------------
    function evaluatePageQuality(text, confidence) {
      const t = text || "";
      const textLen = t.length;

      const ns = t.replace(/\s+/g, "");
      const total = Math.max(1, ns.length);
      const alphaNum = (ns.match(/[A-Za-zА-Яа-я0-9ÄÖÜäöüß]/g) || []).length;
      const alphaNumRatio = alphaNum / total;

      const low = normalize(t);

      const keyPatterns = [
        "termin","einladung","frist","bis zum","spätestens",
        "bitte","wir bitten","sie werden gebeten",
        "unterlagen","nachweis","nachweisen","einreichen","vorlegen","mitwirkung",
        "anhörung","aufforderung","fehlende unterlagen","formular","ausfüllen",
        "summe","euro","leistungen","regelbedarf","mehrbedarf","bedarf"
      ];

      const hasKeySignals = keyPatterns.some(k => low.includes(k));

      const conf = (confidence !== null && typeof confidence === "number") ? confidence : null;

      const confBad = (conf !== null && conf < 50);
      const confOk  = (conf === null || conf >= 55);

      const ratioBad = (alphaNumRatio < 0.45);
      const ratioOk  = (alphaNumRatio >= 0.55);

      const tooShort = (textLen < 80);
      const veryShort = (textLen < 35);

      if (veryShort && (confBad || ratioBad)) {
        return {
          status: "bad",
          reason: "Текста почти нет или он распознан с ошибками. Переснимите или удалите страницу.",
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      if (tooShort && confOk && ratioOk) {
        return {
          status: "warn",
          reason: "На странице мало текста (часть листа пустая), но распознавание хорошее. Анализ возможен. Для максимальной точности можно переснять ближе к тексту.",
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      if (tooShort && hasKeySignals && !confBad && !ratioBad) {
        return {
          status: "warn",
          reason: "Текст распознан частично, но найдены сигналы. Анализ возможен, но для точности лучше переснять страницу.",
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      if (confBad || ratioBad) {
        let reason = "Качество распознавания низкое. Переснимите или удалите страницу.";
        if (confBad && ratioBad) reason = "Страница распознана плохо (низкая уверенность и много мусора). Переснимите или удалите.";
        return {
          status: "bad",
          reason,
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      if (tooShort) {
        return {
          status: "warn",
          reason: "Текста немного. Анализ возможен, но лучше добавить страницу с основной частью письма (Bitte/Frist/Termin), если она есть.",
          metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals }
        };
      }

      return { status: "ok", reason: "", metrics: { textLen, confidence: conf, alphaNumRatio, hasKeySignals } };
    }

    // ---------------- OCR per page (FAST deu, switch to deu+rus only if needed) ----------------
    async function ocrOnePage(pageObj, idx, total) {
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Обрабатываем страницы: " + (idx + 1) + " из " + total;

      // 1) fast OCR: deu
      let worker = await getOcrWorker(OCR_LANG_FAST);
      const r1 = await worker.recognize(pageObj.ocrBlob);

      const rawText1 = (r1.data && r1.data.text) ? r1.data.text : "";
      const cleaned1 = cleanOcrText(rawText1);
      const conf1 = (r1.data && typeof r1.data.confidence === "number") ? r1.data.confidence : null;

      const hasCyr = /[А-Яа-яЁёІіЇїЄє]/.test(cleaned1);

      let cleaned = cleaned1;
      let conf = conf1;

      // 2) switch to full only if кириллица реально есть
      if (hasCyr) {
        pLine1.textContent = "Анализ идёт";
        pLine2.textContent = "Обнаружена кириллица → включаем RU (может занять время)";

        worker = await getOcrWorker(OCR_LANG_FULL);
        const r2 = await worker.recognize(pageObj.ocrBlob);

        const rawText2 = (r2.data && r2.data.text) ? r2.data.text : "";
        cleaned = cleanOcrText(rawText2);
        conf = (r2.data && typeof r2.data.confidence === "number") ? r2.data.confidence : conf1;
      }

      pageObj.ocrText = cleaned;
      pageObj.ocrConfidence = conf;

      const q = evaluatePageQuality(cleaned, conf);
      pageObj.status = q.status;
      pageObj.reason = q.reason || "";
      pageObj.metrics = q.metrics || {};
    }

    // ---------------- Analysis (rule-based, без "возможно/похоже") ----------------
    function findDeadline(text) {
      const m1 = text.match(/\b(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m1) return m1[1];
      const m2 = text.match(/\b(bis zum|spätestens am|frist|fristen|bis spätestens)\s+(\d{1,2}\.\d{1,2}\.\d{2,4})\b/);
      if (m2) return m2[2];
      return "";
    }

    function analyzeText(raw) {
      const t = normalize(raw);
      if (t.length < 100) return { kind: "insufficient", deadline: "", signals: [] };

      const signalsAction = [
        "bitte","wir bitten","sie werden gebeten","sie sind verpflichtet",
        "erforderlich","nachweisen","nachweis","einreichen","vorlegen",
        "termin","einladung","melden sie sich","rückmeldung",
        "frist","bis zum","spätestens","umgehend",
        "anhörung","mitwirkung","aufforderung","fehlende unterlagen",
        "unterlagen","kontoauszüge","mietvertrag","ausfüllen","formular"
      ];

      const found = signalsAction.filter(w => t.includes(w));
      const deadline = findDeadline(t);

      if (found.length >= 2 || (found.length >= 1 && (t.includes("frist") || t.includes("termin") || deadline))) {
        return { kind: "needAction", deadline, signals: found.slice(0, 6) };
      }

      return { kind: "noAction", deadline: "", signals: [] };
    }

    function aboutLetter(raw) {
      const t = normalize(raw);
      if (t.length < 100) {
        return "Текста недостаточно для уверенного вывода. Добавьте страницу с основной частью письма (где указаны просьбы, сроки или термин).";
      }
      const hasTermin = /termin|einladung|melden sie sich|vorsprechen/.test(t);
      const hasDocs = /unterlagen|nachweis|nachweisen|einreichen|vorlegen|mitwirkung|aufforderung|fehlende|ausfüllen|formular/.test(t);
      const hasPay = /bürgergeld|zahlung|auszahlung|betrag|überweisung|monatlich|leistungen|euro|summe/.test(t);
      const hasBescheid = /bescheid|änderungsbescheid|bewilligung|bewilligungsbescheid|mitteilung|veränderungsmitteilung/.test(t);

      if (hasTermin) return "В письме обнаружены слова, связанные с термином/встречей. Обычно это означает необходимость прийти или ответить.";
      if (hasDocs) return "В письме обнаружены слова, связанные с документами/подтверждениями. Обычно это означает необходимость предоставить документы.";
      if (hasPay) return "В письме обнаружены слова, связанные с выплатами/суммами. Часто это информирование о расчётах.";
      if (hasBescheid) return "В письме обнаружены слова, связанные с решением/уведомлением (Bescheid). Проверьте, есть ли сроки или просьбы.";
      return "Письмо содержит общий текст. Для точности важны страницы со сроками/просьбами (Bitte / Frist / Termin).";
    }

    function showResult(res, combinedText) {
      if (res.kind === "needAction") {
        resultTitle.textContent = "✅ Требуется действие";
        resultSupport.textContent = "Это нормально. Ниже — пояснение, что именно требуется.";

        const sig = res.signals.length ? ("Найдены сигналы: " + res.signals.join(", ") + "\n") : "";
        const dl = res.deadline ? ("Срок, указанный в тексте: " + res.deadline + "\n") : "";

        resultDetails.textContent =
          sig + dl +
          "Что сделать:\n" +
          "• проверьте, просят ли предоставить документы (Unterlagen / Nachweis),\n" +
          "• или прийти/ответить по термину (Termin / Einladung),\n" +
          "• или заполнить форму (Formular / ausfüllen).\n\n" +
          "Совет: если в письме есть Bitte / Frist / Termin — это прямой сигнал к действию.";
      }
      else if (res.kind === "noAction") {
        resultTitle.textContent = "❌ Действие не требуется";
        resultSupport.textContent =
          "В распознанном тексте не обнаружены просьбы: прислать документы, ответить или прийти в термин.";

        resultDetails.textContent =
          "Что это значит:\n" +
          "• письмо похоже на информационное уведомление (без обязательных действий).\n" +
          "• если вы ожидаете запрос документов или приглашение — проверьте, не пропущена ли какая-то страница.\n";
      }
      else {
        resultTitle.textContent = "⚠️ Недостаточно данных";
        resultSupport.textContent =
          "Текст распознан частично или отсутствуют ключевые фразы. Добавьте/переснимите страницу с основной частью письма.";

        resultDetails.textContent =
          "Как исправить:\n" +
          "• снимите страницу ближе (текст должен занимать 70–90% кадра)\n" +
          "• уберите блики/тени\n" +
          "• добавьте страницу со словами Bitte / Frist / Termin (если они есть)\n";
      }

      aboutText.textContent = aboutLetter(combinedText);

      doneBanner.style.display = "block";
      resultBox.style.display = "block";
    }

    // ---------------- Events ----------------
    cameraBtn.addEventListener("click", () => {
      if (isLocked) return;
      cameraInput.click();
    });

    filesBtn.addEventListener("click", () => {
      if (isLocked) return;
      filesInput.click();
    });

    cameraInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(cameraInput.files);
    });

    filesInput.addEventListener("change", async () => {
      if (isLocked) return;
      await addFiles(filesInput.files);
    });

    carousel.addEventListener("scroll", () => updateCounters());

    analyzeBtn.addEventListener("click", async () => {
      if (isLocked) return;
      if (pages.length === 0) { showZeroHintIfNeeded(); return; }
      if (hasBadPages()) { updateQualityPanel(); return; }

      // start
      setLocked(true);
      updateQualityPanel();

      resultBox.style.display = "none";
      doneBanner.style.display = "none";

      progressBox.style.display = "block";
      pLine1.textContent = "Анализ идёт";
      pLine2.textContent = "Подготовка OCR (первый запуск может занять время)";

      try {
        // OCR sequential + yield + no full rerender
        for (let i = 0; i < pages.length; i++) {
          await ocrOnePage(pages[i], i, pages.length);
          updateSlideByIndex(i);
          updateCounters();
          await nextFrame();
        }

        // Update quality panel after OCR
        updateQualityPanel();

        // If BAD appeared -> stop (Patch 2: ensure panel/buttons updated after unlock)
        if (hasBadPages()) {
          progressBox.style.display = "none";
          setLocked(false);
          updateQualityPanel();
          showZeroHintIfNeeded();

          const fb = firstBadIndex();
          if (fb >= 0) scrollToPage(fb);

          await closeOcrWorker();
          return;
        }

        // combine text
        pLine1.textContent = "Анализ идёт";
        pLine2.textContent = "Проверяем, требуется ли от вас действие";

        const combinedText = pages.map((p, idx) => `--- Страница ${idx + 1} ---\n${p.ocrText || ""}`).join("\n\n");
        const res = analyzeText(combinedText);

        pLine1.textContent = "Анализ завершён";
        pLine2.textContent = "Ниже — результат проверки письма";

        setTimeout(async () => {
          showResult(res, combinedText);

          progressBox.style.display = "none";
          setLocked(false);
          updateQualityPanel();
          showZeroHintIfNeeded();

          await closeOcrWorker();
        }, 250);

      } catch (e) {
        progressBox.style.display = "none";
        setLocked(false);
        updateQualityPanel();
        showZeroHintIfNeeded();

        resultBox.style.display = "block";
        doneBanner.style.display = "none";
        resultTitle.textContent = "⚠️ Не удалось завершить анализ";
        resultSupport.textContent = "Это нормально. Переснимите страницы ближе и попробуйте ещё раз.";
        resultDetails.textContent =
          "Рекомендации:\n" +
          "• текст должен занимать 70–90% кадра\n" +
          "• без бликов и теней\n" +
          "• переснимите страницы, которые могут быть нечитаемыми\n";
        aboutText.textContent = "—";

        await closeOcrWorker();
      }
    });

    // ---------------- init ----------------
    renderCarousel();
    updateQualityPanel();
    showZeroHintIfNeeded();
  </script>
</body>
</html>
